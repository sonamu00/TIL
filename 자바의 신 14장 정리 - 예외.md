---
share: "true"
---
## 1. 예외(Exception)란 무엇인가
* 예외는 “문법은 맞지만 실행 중에 발생하는 비정상 상황”을 의미하며, 정상 흐름과 분리된 **에러 처리용 제어 구조**다.
* OS/CPU 관점에서는 잘못된 연산(0으로 나누기, 잘못된 메모리 접근 등)이 발생하면 예외·인터럽트가 발생하고 전용 처리 루틴으로 점프하는데, 자바의 예외는 이를 언어 차원에서 구조적으로 지원한 것이라고 볼 수 있다.
* 비즈니스 로직에서 if-else로 처리하기 애매한 상황(파일 없음, DB 접속 불가, 유효하지 않은 요청 등)을 **예외로 분리**하면, 정상 흐름 코드와 에러 처리 코드가 깔끔하게 나뉜다.

---

## 2. 예외 계층 구조 (Throwable, Error, Exception)
* OpenJDK 17 문서에서 `Throwable`은 이렇게 정의된다: “The `Throwable` class is the superclass of all errors and exceptions in the Java language.” ([Oracle Docs][1])
* 예외 계층 구조
	- `java.lang.Object`
	    - `java.lang.Throwable`
		      - `java.lang.Error`
		      - `java.lang.Exception`
* **Error**
	* 애플리케이션 외부에서 발생한 에러를 말한다.
	* “An `Error` is a subclass of `Throwable` that indicates serious problems that a reasonable application should not try to catch.” ([freedocs.mi.hdm-stuttgart.de][2])
	* 예: `OutOfMemoryError`, `StackOverflowError` 등, 보통 애플리케이션에서 복구를 시도하지 않고 그대로 죽게 둔다.
* **Exception**
	- 애플리케이션 레벨에서 발생하는 예외의 상위 타입이다.
	- 이 안에서 다시 `RuntimeException` 계열(언체크)과 그 외(체크)로 나뉜다.
* **RuntimeException**
	- “`RuntimeException` is the superclass of those exceptions that can be thrown during the normal operation of the Java Virtual Machine.” ([OpenJDK CR][3])
	* NPE, `IllegalArgumentException`, `IndexOutOfBoundsException` 등 주로 **프로그래밍 버그나 계약 위반**을 표현한다.

---

## 3. 체크 예외 vs 언체크 예외
* OpenJDK 17 기준으로, `Throwable`과 그 하위 타입 중에서 `RuntimeException`과 `Error`를 제외한 것들을 **체크 예외(checked exception)**로 본다. ([Oracle Docs][1])
* **체크 예외 (checked)**
	* 컴파일러가 `throws` 선언 또는 `try-catch`를 **강제**한다.
	* 주로 파일, 네트워크, DB처럼 **외부 환경·상태 문제**에서 발생하고, 호출 코드에서 적절한 조치를 고려할 여지가 있을 때 사용한다.
	* 예: `IOException`, `SQLException`, 많은 비즈니스용 커스텀 예외(보통 `Exception` 상속)
* **언체크 예외 (unchecked)**
	* 컴파일러가 `throws`를 강제하지 않고, 필요하면 개발자가 선택적으로 `try-catch` 한다. ([OpenJDK CR][3])
	* 보통 **코드 자체의 버그, 잘못된 인자, 계약 위반**처럼 “이 상태에서 계속 진행하면 더 위험한 경우”에 사용한다.
	* 예: `RuntimeException`과 그 자식들, `Error` 계열 예외들
* 설계 관점에서의 기준
	* “이 메서드에서 **진짜로 복구 로직을 써야 하는 예외인가?” → 체크 예외로 설계하는 선택지를 검토
	* “복구하지 않을 것이고 전역에서 공통 처리할 에러인가?” → `RuntimeException` 계열 언체크 예외로 두고, 전역 예외 처리기에서 HTTP 상태·에러 코드로 변환하는 식으로 처리.

---

## 4. 예외 처리 문법: try, catch, finally
```java
try {
    // 예외가 발생할 수 있는 코드
} catch (SomeException e) {
    // 예외 처리 코드
} finally {
    // 예외 발생 여부와 상관 없이 수행 (자원 정리 등)
}
```
* **try 블록**: 예외가 발생할 수 있는 코드를 감싼다.
* **catch 블록**: 특정 타입의 예외를 잡아 처리하며, 상위 타입(`Exception`, `Throwable`)은 더 넓게 잡는다.
* **finally 블록**: 예외 발생 여부와 관계없이 실행되며, 주로 DB 커넥션, 파일 스트림, 락 해제 등 **자원 정리**에 사용한다.
* catch 여러 개 사용 시
	* 더 구체적인 타입을 **위에**, 추상적인 타입을 **아래에** 두어야 한다.
	* 예: `NullPointerException` → `RuntimeException` → `Exception` 순으로 배치.

---

## 5. 예외 전파와 throws
* 메서드 선언부에 `throws`를 사용해서 “이 메서드는 이런 예외를 **던질 수 있다**”는 것을 알린다.
```java
public void readConfig() throws IOException {
    // 내부에서 IOException이 발생할 수 있는 코드
}
```
* 체크 예외는 `throws` 또는 `try-catch` 어느 쪽이든 **필수**이고, 언체크 예외는 선택이다.
* 예외 전파 흐름
	* 메서드 안에서 예외가 발생하면 현재 메서드는 즉시 종료되고 호출 스택을 타고 위로 올라가다가, 해당 타입을 처리하는 `catch`를 만나면 그곳에서 처리된다.
	* 아무도 잡지 않으면 최상단(메인 스레드)까지 올라가며, 보통 프로그램 종료 또는 HTTP 500 응답으로 이어진다.

---

## 6. throw와 throws의 차이
* **`throw`**
	* “지금 이 위치에서 **예외 객체를 실제로 발생**시킨다”는 의미.
```java
if (!canConnect()) {
    throw new DbConnectionException("DB 연결 실패");
}
```
* **`throws`**
	* “이 메서드는 이런 예외를 **밖으로 던질 수 있다**”는 **선언**으로, 메서드 시그니처에 붙는다.
```java
public void load() throws IOException {
    // 내부에서 IOException이 발생할 수 있는 작업
}
```
* 둘은 같이 사용할 수도 있다.
```java
public void doSomething() throws MyException {
    throw new MyException("문제 발생");
}
```

---

## 7. 커스텀 예외 설계
* 기본 형태
```java
public class BizException extends RuntimeException {
    public BizException(String message) {
        super(message);
    }
}
```
* 설계 기준
	* **도메인 예외**
		* 비즈니스 규칙 위반(이미 등록된 사용자, 권한 없음 등)을 표현.
		* 주로 `RuntimeException` 상속으로 만들고, 컨트롤러 단에서 전역 예외 처리기로 받아 HTTP 400·403 등으로 매핑한다.
	* **시스템/인프라 예외**
		* DB 접속 불가, 외부 HTTP API 장애, 메시지 큐 연결 실패 등.
		* 대부분 서비스 코드에서 복구하지 않고 요청 전체를 실패 처리 → `DbConnectionException` 같은 RuntimeException 계열 예외로 만들어서 HTTP 500 등으로 매핑한다.
	* 메시지/코드 설계
		* 예외 안에 **에러 코드(예: `BIZ-1001`) + 사용자용 메시지 + 로그용 상세 메시지**를 넣어두고, 전역 예외 처리기에서 각각 UI 메시지, 로그 파일, 모니터링 시스템에서 재사용할 수 있게 설계할 수 있다.

---

## 8. 운영·실무 관점에서의 예외 처리 흐름
* 일반적인 웹 애플리케이션 3계층 구조 기준
	  * **Controller**: 요청·응답 변환, DTO 변환, 전역 예외 처리기와 연동
	  * **Service**: 비즈니스 로직, 도메인 예외(`BizException`, `UserNotFoundException` 등) 발생
	  * **Repository/DAO**: DB 연동, 체크 예외(`SQLException` 등)를 받아 RuntimeException 계열(`DataAccessException`, `DbConnectionException` 등)로 래핑
* 패턴
	* 저수준(DAO)에서 나오는 체크 예외는 그 레이어 안에서 `try-catch` 후 **RuntimeException으로 래핑해서 던진다**. ([Oracle Docs][4])
	* 서비스와 컨트롤러는 상세 기술(JDBC, 특정 드라이버 예외 타입)에 의존하지 않고, 도메인·시스템 예외만 신경 쓴다.
	* 최상단에서는 전역 예외 처리(스프링 `@ControllerAdvice`)에서 예외 타입 → HTTP 상태 코드·에러 코드·사용자 메시지로 변환해 응답한다.
* 이런 구조를 쓰면
	* 도메인 로직은 “정상 흐름”에 집중할 수 있고,
	* 예외 처리 정책은 한 곳(전역 핸들러)에서 통일해서 관리할 수 있으며,
	* 나중에 DB나 외부 연동 기술이 바뀌어도 상위 계층 시그니처를 최소한만 수정하게 된다.

---

## 9. 요약
* 모든 예외의 최상위 타입은 `Throwable`이며, `Error`와 `Exception` 두 가지 축으로 나뉜다. ([Oracle Docs][1])
* 체크 예외는 `RuntimeException`/`Error`를 제외한 `Throwable` 하위 타입으로, 컴파일러가 `throws` 또는 `try-catch`를 강제한다.
* 언체크 예외는 `RuntimeException`/`Error` 계열로, 주로 버그·계약 위반을 표현하며 컴파일러가 강제하지 않는다.
* `throw`는 “지금 여기서 예외를 던져라”, `throws`는 “이 메서드는 이 예외를 던질 수 있다”는 선언이다.
* 실무에서는 DAO에서 체크 예외를 RuntimeException으로 래핑하고, 서비스/컨트롤러에서는 도메인·시스템 예외 중심으로 설계한 뒤 전역 예외 처리기에서 최종 응답으로 변환하는 패턴을 많이 쓴다.

---

## 참고
[1]: https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Throwable.html?utm_source=chatgpt.com "Throwable (Java SE 17 & JDK 17)"
[2]: https://freedocs.mi.hdm-stuttgart.de/lib/openjdk-17-doc/api/java.base/java/lang/Error.html?utm_source=chatgpt.com "Error (Java SE 17 & JDK 17)"
[3]: https://cr.openjdk.org/~hannesw/snippet-bling/01/java.base/java/lang/RuntimeException.html?utm_source=chatgpt.com "RuntimeException (Java SE 17 & JDK 17 [ad-hoc build])"
[4]: https://docs.oracle.com/en/java/javase/17/docs/api/java.sql/java/sql/SQLException.html?utm_source=chatgpt.com "SQLException (Java SE 17 & JDK 17)"
