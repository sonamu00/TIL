
## 오토박싱이란
- 기본 타입을 래퍼 객체로 자동으로 감싸주는 것
- 기본타입 변수와 래퍼 타입 객체를 같이 연산할 때나 래퍼 타입 객체에 기본 타입 값을 넣었을 때 발생
	- ex 1) `Integer a = 10;   // Integer 객체로 자동 변경`
	- ex 2) `Integer sum = sum + 10; // 연산한 값을 Integer 객체로 새로 생성`

## valueOf 메서드
- 래퍼 객체를 생성할 때 **캐시**가 있으면 객체를 새로 생성 X -> 기존 객체 사용 (싱글톤 패턴)
- 오토박싱과의 연관관계: javac가 컴파일할 때 타입 규칙으로 판단하고 오토박싱이 필요하면 바이트코드에 `valueOf` 메서드를 넣음

### Integer 래퍼 객체 생성 방법
- valueOf 메서드에서 캐시된 값이 있는지 확인
- 기본 캐시 범위는 -128 ~ 127의 정수 범위, JVM 옵션으로 캐시 크기 설정 가능(`-XX:AutoBoxCacheMax=<size>`)
-  기본 캐시 범위가 -128 ~ 127 인 이유: int 범위는 너무 넓음 -> 전부 캐시하면 메모리 낭비가 큼 -> 자주 쓰이는 값들(0, 1, -1, 작은 인덱스, 상태값 등)이 byte 범위에 모여 있어서 byte 범위만 캐시
- 자바 구현 코드:
	``` java
@IntrinsicCandidate  
public static Integer valueOf(int i) {  
	if (i >= IntegerCache.low && i <= IntegerCache.high)  // 캐시 범위 체크
		return IntegerCache.cache[i + (-IntegerCache.low)];   // 오프셋 계산에서 캐시에서 값 꺼냄
	return new Integer(i);  // 캐시 범위 밖이면 새 객체 생성
}
	```

### Boolean 래퍼 객체 생성 방법
- valueOf 메서드에서 매개변수로 넘어온 값이 true/false인지 확인하고 리턴할 때 불변 Boolean 래퍼 객체를 넘김
- Boolean은 true/false 두 가지 값만 존재하기 때문에 미리 불변 객체를 만들어두고 재사용하도록 함
- 자바 구현 코드:
``` java
public static final Boolean TRUE = new Boolean(true);  
public static final Boolean FALSE = new Boolean(false);
 
@IntrinsicCandidate  
public static Boolean valueOf(boolean b) {  
    return (b ? TRUE : FALSE);  
}
```

## 오토박싱의 문제점과 사이드 이펙트
### 누적/카운트/합계 연산 시 객체 생성
``` java
Long sum = 0L;
for (int i = 0; i < n; i++) sum += i; // 매 반복마다 언박싱 + 연산 + 박싱
// => sum = Long.valueOf(sum.longValue() + i); 이것과 같음
```
- 연산을 할 때마다 오토박싱이 일어나고, 래퍼 클래스는 객체이기 때문에 새로운 객체가 연산할 때마다 생성됨 => GC 부담 가중

### 컬렉션/스트림에 다중 래퍼 객체 생성
- `List<Integer>`는 내부에 `Integer` 객체를 저장 → 데이터가 클수록 객체 수가 그대로 늘어남
- `Stream<Integer>`에서 `map`, `reduce` 등 하면 중간 객체/박싱이 늘 수 있음
- 해결 방법
	- 컬렉션에 대량 수치를 저장해야 된다면 프리미티브 타입 배열로 바꾸기(`int[]`, `long[]`, `double[]`)
		- ex)
			- `List<Integer>`: “참조 배열 + Integer 객체 N개”
			- `int[]`: “연속된 4바이트 N개
	- 스트림을 쓰는 경우 Primitive Stream 으로 변환
		- 예시 코드:
			``` java
			// ❌ 박싱 Stream<Integer>
			Stream<Integer> s = ...
			
			// ✅ IntStream/LongStream
			IntStream s = ...
			long sum = s.sum();
			```

### 멀티 스레드에서 공유된 값 원자성 깨짐
``` java
Integer count = 0;   // 공유
// 여러 스레드가 동시에:
count++;             // ❌
```
- count 값을 증가할 때 순서
	- **읽기(read)**: 현재 `count` 값을 가져옴
	- **수정(modify)**: +1 계산
	- **쓰기(write)**: 결과를 다시 `count`에 넣음
	=> 여러 스레드가 동시에 실행하면 둘 다 같은 옛값을 읽어 계산하여 마지막에 서로 덮어써서 **증가가 누락**된다.
- 해결 방법
	- `AtomicInteger` 사용
		- 읽기/계산/쓰기가 쪼개지지 않고, 한 동작처럼 보장되어서 동시 실행에서도 누락이 없음
		- 스레드가 많고 동시에 증가하면 CAS(Compare-And-Swap) 실패가 잦아지는 문제가 있음
		- 증가 직후 현재값이 정확해야 하거나, 읽기가 매우 잦을 때 사용 권장
			- ex) 정확한 순번/ID 발급, 상태 플래그/상태 전이(한 번만 실행, 초기화 1회 등), 정확한 현재값이 로직 분기 조건인 경우
	- `LongAdder` 사용
		- 내부에 여러 개의 카운터(셀 cell)를 만들어서 **각 스레드가 자기 셀**에 증가를 기록
		- `long total = LongAdder.sum();` 메서드로 셀 여러개를 합쳐야 결과를 확인할 수 있음 -> **여러 셀을 합치는 순간**, 동시에 증가가 일어날 때에 값은 정확하지 않을 수 있음
		- 여러 스레드에서 자주 쓰거나 수정하지만 읽기는 적게할 때 사용 권장
			- ex) 로그/메트릭/트래픽 카운트(초당 요청 수), 이벤트 수집(클릭 수, 처리 건수), 모니터링 지표(에러 카운트)
