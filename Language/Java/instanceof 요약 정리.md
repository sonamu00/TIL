## instanceof 란
- 객체의 타입이 런타임에서 특정 클래스 또는 인터페이스 타입인지 검사하는 연산자
- 컴파일 시점이 아니라 **런타임에 평가됨**

## JVM 내부 실행 순서
#### 1. 바이트코드 실행
- `instanceof`(또는 `checkcast`) 명령이 실행됨.
#### 2. null 체크
- 대상 참조가 `null`이면 결과는 **무조건 `false`**
#### 3. 객체의 실제 타입(Klass) 얻기
- 객체(obj)가 어떤 클래스에서 만들어진 객체인기 확인하는 과정임
- 객체 헤더의 **klass 포인터**를 따라가서 그 객체의 **실제 Klass(메타데이터, Metaspace/네이티브 메모리)** 를 가져옴
#### 4. 비교 대상 타입(T)의 Klass 확보
- 비교 대상 타입은 이미 코드에 적혀 있기 떄문에 타입 정보를 상수풀에서 먼저 확인
- 상수풀에 Klass가 있으면 해당 Klass 포인터를 바로 사용
- 상수풀에 Klass 가 없으면 클래스 로딩해서 Klass를 만든 뒤, 생성한 Klass를 씀 
#### 5. 서브타입 검사 분기
- JVM은 "T가 클래스냐 / 인터페이스냐"에 따라 검사 경로가 달라짐.
#### 5-1. 클래스(상속) 타입 체크 경로
- 클래스 상속은 단일 상속만 가능하기 때문에 경로가 선형 구조임
- Klass 를 생성할 때, JVM이 타입 체크를 빠르게 하기 위해 정해진 슬롯/오프셋(배열의 인덱스처럼) 형식으로 정보를 넣음
- instanceof로 타입을 체크할 때는 Klass 내부의 **빠른 체크용 정보(primary supers / 오프셋 기반)** 를 이용해 정해진 슬롯에서 빠르게 타입 존재 여부를 확인  
#### 5-2. 인터페이스 타입 체크 경로
- 인터페이스는 다중 구현이 가능하기 때문에 경로가 목록(집합) 구조임
- Klass를 생성할 때, 구현 인터페이스들의 목록(집합) 형태로 정보를 넣음
- instanceof로 타입을 체크할 때에는 Klass에 있는 **인터페이스 집합(목록/배열 개념, secondary supertypes)** 을 기반으로 타입 존재 여부를 확인
###### JDK 버전별 인터페이스 체크 방식
- JDK 24 이전
	- 인터페이스 목록에서 찾음(스캔)
	- 다음에 타입 체크를 할 때 빠르게 하려고 최근 타입 체크 결과 1개를 캐시(SSC)에 저장
	- **목록 스캔 + 1-원소 캐시(secondary_super_cache) 갱신** 경로
    - 문제점: 멀티스레드에서 서로 캐시를 갱신하기 위해 캐시라인 핑퐁이 일어남 -> 성능 병목(JDK-8180450)
- JDK 24 이후
	- 타입 체크 결과를 캐시(secondary_supet_cache)에 저장하지 않는다.
	- 해시테이블 조회 방식으로 경로 탐색하는 것으로 변경됨
