## 기본 정보
- **주제:** 타입 소거
- **적용 버전:** JDK 1.5
- **마지막 검증일:** 2026-01-12
- **공식 레퍼런스:** 
-  **정보 신뢰도:**  
	- [x] 공식문서 
	- [ ] 직접실험 
	- [x] 블로그 
	- [ ] 스택오버플로우 
	- [ ] 기타 

---

## 기술의 명세와 한계
| **구분** | **보장 내용 **                                 | **전제 조건 **                              | **근거 **                                                                                        |
| ------ | ------------------------------------------ | --------------------------------------- | ---------------------------------------------------------------------------------------------- |
| 보장 1   | **바이너리 호환성 유지**: 구버전 라이브러리도 새 JDK에서 정상 실행됨 | 제네릭 정보는 컴파일 시에만 사용, 런타임 시그니처는 기존과 동일함   | 구버전이 호출하는 `Object` 기반 시그니처가 바뀌면 런타임 링크 에러가 발생                                                  |
| 보장 2   | 런타임 타입 체크 비용 거의 없음                         | 런타임에 타입 인자를 유지하지 않고 필요 시 캐스트를 삽입함       | 컴파일 타임에 검사를 끝내고 런타임에는 기존과 유사한 호출 경로를 유지하여 성능을 보존함                                              |
| 보장 3   | 소스 레벨 타입 안정성 제공                            | raw type, unchecked 변환을 회피함             | 컴파일러가 타입 불일치를 사전에 포착하고 필요한 캐스트를 자동 삽입하여 실행 전 안전을 확보함                                           |
| 보장 4   | **오버라이딩 호환성 보완**: 소거 후에도 상속 구조의 다형성을 유지함   | 컴파일러가 `bridge`, `synthetic` 메서드를 자동 생성함 | 소거로 인해 부모(`Object`)와 자식(`String`)의 메서드 타입이 달라져 오버라이딩이 깨지는 것을 막기 위해, 중간 다리(Bridge) 메서드를 만들어 연결함 |

| 구분   | 깨지는 상황                                                                             | 실패 모드                                              | 대응 전략                                                                   |
| :--- | :--------------------------------------------------------------------------------- | :------------------------------------------------- | :---------------------------------------------------------------------- |
| 한계 1 | 런타임에 타입 인자를 식별해야 하는 요구: `instanceof List<String>`, `new T()`, `T.class`, 제네릭 배열 생성 | 컴파일 에러 또는 표현 불가                                    | 타입 토큰 전달(`Class<T>`), 팩토리 주입, 컬렉션으로 대체, 런타임 검증 로직을 명시적으로 추가             |
| 한계 2 | raw type 혼용, unchecked cast, 제네릭 경고를 무시                                            | 런타임 `ClassCastException` 등으로 늦게 폭발, 타입 안정성 붕괴      | raw 제거, 경고를 에러급으로 관리(`-Xlint:unchecked`), API 경계를 제네릭으로 강제, 테스트로 경계값 검증 |
| 한계 3 | 가변 인자와 제네릭 배열이 만나는 경우(비구체화 타입, heap pollution)                                     | 컴파일 경고, 드물게 런타임 타입 오류                              | 가변 인자 대신 `List`로 받기, 불가피하면 `@SafeVarargs`와 내부 방어 복사, 배열 노출 금지           |
| 한계 4 | 리플렉션으로 제네릭을 완전히 복원하려는 경우                                                           | 런타임에서 타입 인자가 소거되어 일부 정보만 확인 가능, 프레임워크에서 예외적 케이스 발생 | 필요한 타입 정보를 별도 메타데이터로 보관, 슈퍼 타입 토큰 패턴 사용, 설계 단계에서 런타임 타입 의존을 줄이기         |

---

## 트레이드 오프 분석
- 비교 대안:
    - 대안 1: 실행 중에도 제네릭 타입을 그대로 남긴다
        - 장점: 실행 중에도 `List<String>`과 `List<Integer>`를 구분할 수 있다. 그래서 `instanceof` 같은 것도 더 자연스럽게 된다
        - 단점: 기존에 이미 배포된 수많은 라이브러리와 코드가 깨질 위험이 커진다. JVM과 표준 라이브러리도 크게 바꿔야 한다
    - 대안 2: 타입마다 별도 코드나 클래스를 많이 만들어 최적화한다
        - 장점: int 같은 기본 타입도 박싱 비용을 줄이면서 빠르게 만들 수 있다
        - 단점: 만들어지는 클래스나 코드가 폭증해서 컴파일과 배포가 복잡해진다
    - 대안 3: 런타임에 타입을 알아야 하면 사용자가 타입 정보를 항상 넘기게 강제한다
        - 장점: 실행 중 타입이 필요할 때 확실히 알 수 있다
        - 단점: API가 장황해지고 사용성이 떨어진다. 모든 호출이 번거로워진다
- 당시의 맥락: (왜 이런 고민을 했나?)
    - Java 5가 나올 때 이미 시장에 Java 1.4 이전에 컴파일된 코드와 라이브러리가 엄청 많았고, 그것들이 새 버전 Java에서도 그대로 돌아가야 했다
    - 그래서 실행 중 동작 방식이나 메서드 호출 규칙을 크게 바꾸는 선택은 위험했다
- 선택 이유:
    - 타입 소거를 쓰면 제네릭은 소스 코드에서만 안전성을 주고, 실행 중에는 기존 방식(Object 기반)과 최대한 같게 유지할 수 있다
    - 기존 라이브러리와의 호환성을 지키면서도 개발자는 컴파일 타임에 타입 실수를 줄일 수 있게 된다

---

## 검색 고리 
- **Quick Query:** 자바 제네릭 타입 소거, JLS 4.6 타입 소거, 제네릭 브리지 메서드, 비검사 변환 JLS 5.1.9, 비구체화 타입 힙 오염
- **트러블슈팅 키워드:** NoSuchMethodError 브리지 메서드, ClassCastException 제네릭 타입 소거, unchecked cast 경고, varargs 힙 오염, Method.isBridge true, synthetic bridge 메서드 javap, 타입 추론 실패 incompatible types
- **추가 학습 키워드:** 구체화 타입 vs 비구체화 타입, raw type 위험, Signature attribute 제네릭 정보, javap -v 시그니처 확인, 타입 토큰 `Class<T>`, ParameterizedType TypeVariable, 타입 추론 바운드, 공변 반환 브리지 메서드

---

## 관련 참고 자료
##### 입문
- 제네릭 타입 소거 컴파일 과정, 브리지 메서드까지 한 번에
	- https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%83%80%EC%9E%85-%EC%86%8C%EA%B1%B0-%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EA%B3%BC%EC%A0%95-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0

- 제네릭 큰 그림, 타입 소거 파트 포함
	- https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%A0%9C%EB%84%A4%EB%A6%ADGenerics-%EA%B0%9C%EB%85%90-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%B3%B5%ED%95%98%EA%B8%B0

- 제네릭 기초 정리 (타입 매개변수, 제한, 와일드카드 흐름)
	- https://st-lab.tistory.com/153

- 타입 경계, 타입 소거 규칙, 브릿지 메서드 예시
	- https://ejjoo.github.io/java/2019/12/31/java-generic.html

- 타입 소거 개념과 비구체화 타입, 왜 헷갈리는지 설명
	- https://devlog-wjdrbs96.tistory.com/263

- 힙 오염이 왜 타입 소거와 엮이는지, 어떤 케이스가 위험한지
	- https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%9E%99-%EC%98%A4%EC%97%BC-Heap-Pollution-%EC%9D%B4%EB%9E%80



##### 기본 (공식 문서 중심, 중간)
- Generics 전체 목차 (공식 튜토리얼 허브)
	- https://docs.oracle.com/javase/tutorial/java/generics/index.html

- Type Erasure 핵심 요약 (치환, 캐스트 삽입, 브리지 메서드 생성)
	- https://docs.oracle.com/javase/tutorial/java/generics/erasure.html

- Erasure of Generic Types (타입 소거 규칙을 예제로 자세히)
	- https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html

- Effects of Type Erasure and Bridge Methods (브리지 메서드가 왜 필요한지)
	- https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html

- Non-Reifiable Types and Heap Pollution (비구체화 타입, 힙 오염, 경고가 왜 뜨는지)
	- https://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html

- javac 도구 명세 (경고와 컴파일 옵션을 공식 기준으로 확인)
	- https://docs.oracle.com/en/java/javase/21/docs/specs/man/javac.html


##### 심화 (스펙, 바이트코드, 도구)
- JLS 4장 (여기에서 4.6 타입 소거, 4.7 구체화 타입, 4.8 raw type을 바로 확인)
	- https://docs.oracle.com/javase/specs/jls/se21/html/jls-4.html#jls-4.6
	- https://docs.oracle.com/javase/specs/jls/se21/html/jls-4.html#jls-4.7
	- https://docs.oracle.com/javase/specs/jls/se21/html/jls-4.html#jls-4.8

- JLS 5장 (unchecked conversion과 힙 오염이 어떻게 런타임 예외로 이어지는지)
	- https://docs.oracle.com/javase/specs/jls/se21/html/jls-5.html#jls-5.1.9

- JLS 13장 (타입 매개변수의 bound 변경이 이진 호환성에 주는 영향)
	- https://docs.oracle.com/javase/specs/jls/se21/html/jls-13.html

- JVMS 4장 (ACC_BRIDGE, Signature attribute 같은 바이트코드 레벨 근거)
	- https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html

- javap 도구 명세 (class 파일을 디스어셈블해서 브리지 메서드와 시그니처 확인)
	- https://docs.oracle.com/en/java/javase/21/docs/specs/man/javap.html

- reflection Method.isBridge (브리지 메서드 판별, 스펙과 연결되는 공식 설명)
	- https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/reflect/Method.html