한 줄 요약: 싱글톤은 인스턴스 1개만 있어야 하는데, **리플렉션/직렬화** 같은 우회로로 깨질 수 있어서 설계가 중요

## 싱글톤이란
- 인스턴스를 오직 하나만 생성할 수 있는 클래스
- 싱글톤을 적용하는 케이스
	- 무상태 객체: 필드가 없거나, 필드가 있어도 상수여서 다음 호출에 영향을 주지 않는 객체
	- 설계상 유일해야 되는 시스템 컴포넌트: 프로세스(JVM) 안에서 하나만 있어야 하는 모듈
		- ex: 애플리케이션 설정/레지스트리(전역 설정 관리자), 로깅/감사 로깅(정책을 한 군데서 통제), 스케줄러/잡 레지스트리(두 개면 작업이 두 번 돌 수 있음)
- 단점: 클래스를 싱글턴으로 만들면 테스트가 어려움
	- 싱글톤이 **전역 접근점**을 제공하면 테스트 간 상태가 섞이기 쉽고, 의존성을 주입하기 어려워 대체 구현/격리가 힘들어짐
	- 설계가 의존성(DI)을 주입하기 어려우면 mock 을 쓰기 어려움 

## 싱글톤 구현 방법 3가지
### public static final 필드 방식
- 예: `public static final Elvis INSTANCE = new Elvis();`
- 장점: 
	- 간단하고 직관적
	- JVM이 딱 1개 생성 보장
- 단점: 
	- 직렬화/리플렉션에 추가 대응 필요

### 정적 팩터리 방식
- 예: `public static Elvis getInstance() { return INSTANCE; }`
- 장점:
	- API 유연성(나중에 싱글톤 → 멀티톤으로 변경 가능)
	- 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있음
	- 정적 팩터리의 메서드 참조를 공급자(suppiler)로 사용 가능
		- suppiler
			- 입력(인자) 없이 `T`를 가져다 주는 것을 제공하는 인터페이스
			- 값을 필요할 때만 만들거나 가져오기 위해 `Supplier<T>` 를 사용
			- 변수/필드/파라미터로 나중에 호출할 함수를 저장하거나 받으려면 타입이 필요해서 이렇게 씀
		- 예시코드:
			``` java
			import java.util.function.Supplier;
			
			Supplier<Long> now = System::currentTimeMillis; // 저장
			long t = now.get();                             // 나중에 호출
			```
- 단점: 필드 방식과 비슷하게 우회 공격(직렬화/리플렉션) 고려 필요

### enum 싱글톤 (권장)
- 예: `enum Elvis { INSTANCE; }`
- 장점: **직렬화 자동 안전**, 리플렉션에도 강함, 가장 간단/안전
- 단점: 
	- 지연 초기화(lazy init) 컨트롤이 어려움
	- 프레임워크가 객체 생성을 마음대로 해야 하는 구조에서는 enum이 불편할 수 있음
		- 프록시 기반으로 동작하는 기능(ex: AOP)에서는 패턴에 안 맞음
		- enum은 생성자를 외부에서 호출 못하고 상속도 못함 => 객체 생성을 프레임워크에서 통제하기 어려움


## 싱글톤이 깨지는 케이스
-  리플렉션
	- `private` 생성자도 강제로 호출 가능 → 인스턴스 여러 개 생성될 수 있음
	- 해결책: 
		- 생성자에서 이미 생성되었는지 체크하고 예외 던지기 (완벽 방어는 아님)
- 직렬화/역직렬화
	- 역직렬화는 저장된 상태를 복원하려고 새 인스턴스를 하나 만들어버림
	- 결과: 싱글톤이 2개 이상 생길 수 있음
	- 해결책:
		- 역직렬화될 클래스에 `readResolve()` 메서드를 추가하여 직렬화로 만들어진 새 객체 대신 **기존 싱글톤 인스턴스**를 반환하도록 구현
		- 직렬화 대상 필드에 `transient` 를 붙여서 역직렬화가 필드를 복원하기 위해 값 주입을 시도하지 못하도록 방지
- 클래스로더
	- 다른 클래스 로더에서 로드되면 다른 클래스 취급 → 인스턴스가 별개로 생길 수 있음
