---
share: "true"
---
## 1. 상속의 기본 개념
- 상속은 공통의 상태와 행동을 가진 클래스를 부모로 두고, 세부적으로 약간씩 다르거나 확장이 필요할 때 자식 클래스를 만드는 메커니즘이다.
- 상속 관계는 “A는 B이다(is-a)”가 자연스러울 때 사용하는 것이 좋고, “A는 B를 가진다(has-a)” 관계라면 필드로 포함하는 것이 더 적절하다.
- 예: `AdminUser extends User`는 “관리자는 사용자다”라는 is-a 관계라 상속이 자연스럽지만, `Car extends Engine`은 “자동차는 엔진이다”가 아니라 “엔진을 가진다”라서 상속보다 포함이 맞다.
    

## 2. 상속과 객체 생성, `super()` 호출
- `new Child()`가 실행되면 힙에는 “Parent 부분 + Child 부분”이 한 덩어리로 생성되고, 스택에는 `Child()` 생성자 호출 스택 프레임이 올라간다.
- 자식 생성자가 실행될 때는 항상 부모 생성자가 먼저 실행되며, 자바 컴파일러가 자식 생성자 첫 줄에 자동으로 `super();`를 삽입한다.
- 부모 클래스에 기본 생성자(매개변수 없는 생성자)가 없으면, 컴파일러가 자동으로 넣으려는 `super();`를 호출할 수 없어서 컴파일 에러가 발생하며, 이때는 자식 생성자에서 부모의 생성자 시그니처에 맞게 `super(값);`을 명시적으로 호출해야 한다.
- 부모 생성자가 먼저 실행되는 이유는 **부모가 자신의 필드 초기화를 책임**져야 하고, 자식이 부모의 내부 상태까지 직접 건드리게 하면 **캡슐화**가 깨지기 때문이다.
    

## 3. 메서드 오버라이딩과 다형성의 연결
- 메서드 오버라이딩은 부모 클래스의 메서드를 자식 클래스에서 **같은 시그니처로 재정의**하는 것이다.
- 오버라이딩 조건
	- 메서드 이름 같아야 함
	- 매개변수 타입/개수/순서가 같아야 함
	- 접근 제어자는 같거나 접근 범위가 확장되어야 하고 축소되면 안됨
	- 반환 타입은 같거나 더 구체적인 타입만 허용됨
		- 구체적인 타입: 부모 메서드의 반환 타입을 자식 타입(서브클래스)으로 사용하는 것
		 예시 코드:
			``` java
			class AnimalFactory {
			    Animal create() { 
			        return new Animal();
			    }
			}
			
			class DogFactory extends AnimalFactory {
			    @Override
			    Dog create() {   // ✅ 더 구체적인 타입으로 오버라이딩 가능
			        return new Dog();
			    }
			}
			```
- 오버라이딩된 메서드는 **런타임에 실제 인스턴스 타입 기준으로 호출 대상이 결정**되며, 이것이 다형성(polymorphism)의 핵심이다.
예시 코드:
```java
class Animal {
    void speak() { }
}

class Dog extends Animal {
    @Override
    void speak() { }
}
```

실행 시:
```java
Animal a1 = new Animal();
Animal a2 = new Dog();

a1.speak(); // Animal.speak()
a2.speak(); // Dog.speak()
```
- 컴파일 타임에는 `a1`, `a2` 모두 타입이 `Animal`이라서 “Animal에 `speak()`가 있다” 정도만 확인한다.
- 런타임에는 `a1`에는 진짜 `Animal` 객체, `a2`에는 진짜 `Dog` 객체가 들어있으므로 JVM이 객체의 실제 타입을 보고 `Dog.speak()`를 호출한다.
- 내부적으로는 객체 헤더에 붙은 런타임 타입 정보와 메서드 테이블을 참조해 실제 타입의 `speak()` 구현을 찾아가는 방식으로 이해하면 된다.
    

## 4. 메서드 오버로딩과 컴파일 타임 결정
- 메서드 오버로딩은 같은 이름의 메서드를 매개변수 목록(타입, 개수, 순서)을 달리해서 여러 개 정의하는 것이다.
- 오버로딩 조건: 메서드 이름은 같아야 하고, 매개변수 목록이 달라야 하며, 반환 타입이나 접근 제어자만 바뀐다고 해서 오버로딩이 성립하지는 않는다.
예시:
```java
void print(String msg) { }
void print(String msg, int count) { } // ✅ 오버로딩

void print(String msg) { }
int  print(String msg) { return 0; } // ❌ 오버로딩 아님, 컴파일 에러
```
- 어떤 오버로딩된 메서드가 호출될지는 **컴파일 시점에 인자 타입과 개수만 보고 결정**되며, 실행 중에 바뀌지 않는다.
    
## 5. 업캐스팅과 다운캐스팅
```java
class Animal { }
class Dog extends Animal { }
```

- 업캐스팅(Upcasting): 자식 타입을 부모 타입으로 참조하는 것(`Dog` → `Animal`)이며 항상 안전하고 자동 형변환이 일어난다.
    ```java
    Dog d = new Dog();
    Animal a = d; // 업캐스팅, 자동 형변환
    ```
    
- 다운캐스팅(Downcasting): 부모 타입을 자식 타입으로 돌려서 사용하는 것(`Animal` → `Dog`)이며 강제 형변환이 필요하고, 실제로 그 자식 타입 객체가 들어있지 않으면 런타임에 `ClassCastException`이 발생한다.
    ```java
    Animal a1 = new Animal();
    Animal a2 = new Dog();
    
    Dog d1 = (Dog) a2; // 실제로 Dog가 들어 있어서 OK
    Dog d2 = (Dog) a1; // 컴파일은 되지만 런타임에 ClassCastException
    ```
- 컴파일 타임에는 “형변환 문법이 맞는지” 정도만 체크하고, 런타임에는 객체의 실제 타입 정보(객체 헤더에 저장된 타입)를 보고 캐스팅이 가능한지 검사한다.
    

## 6. `instanceof`와 안전한 다운캐스팅
- 다운캐스팅은 런타임 에러 위험이 있기 때문에 보통 `instanceof`를 사용해서 실제 타입을 확인한 뒤 캐스팅한다.
    ```java
    Animal a = ...;
    if (a instanceof Dog) {
        Dog d = (Dog) a;
        // Dog 전용 로직 수행
    }
    ```
- `instanceof`는 “이 참조가 가리키는 실제 객체가 어떤 타입인지”를 런타임에 확인하는 연산이다.
- 실무에서는 `instanceof`로 곳곳에서 분기하기보다는, 가능한 한 **부모 타입의 추상 메서드 + 오버라이딩**으로 분기를 감추고, 정말 unavoidable한 특수 처리에만 `instanceof`를 쓰는 것이 좋다.
    

## 7. 다형성 활용 패턴 (변수, 매개변수, 리턴 타입)
- 다형성은 “부모 타입 하나로 여러 자식 타입을 다루는 것”이며, 변수, 매개변수, 리턴 타입에 모두 적용할 수 있다.
    ```java
    void handle(Animal animal) {
        animal.speak(); // Dog면 Dog.speak(), Cat이면 Cat.speak()
    }
    ```
- 호출 측에서는 `Animal` 타입만 의존하고, 실제 구현은 `Dog`, `Cat` 등 여러 자식 타입을 자유롭게 교체할 수 있어 확장성과 테스트 용이성이 좋아진다.
- 실무 예시: `PaymentService`, `MessageSender`, `UserRepository` 같은 인터페이스 타입으로 의존하고, 실제 구현은 `CardPaymentService`, `KakaoPayService` 등으로 런타임에 바꿔 끼우는 구조가 다형성 활용의 전형적인 패턴이다.
    

## 8. 추상 클래스(abstract class)
- 추상 클래스는 공통 상태와 공통 구현을 갖고 있으면서, 자식이 반드시 구현해야 하는 추상 메서드를 함께 정의한 “반쯤 완성된 부모 클래스”이다.
- 특징
    - `abstract class`로 선언하며, `new`로 직접 인스턴스를 만들 수 없다.
    - 필드(상태)와 일반 메서드를 가질 수 있고, 추상 메서드도 함께 가질 수 있다.
    - 상속은 단일 상속만 가능하다(`extends` 한 번).
- 실무에서 공통 로깅, 공통 예외 처리, 공통 유효성 검사 등을 기본 구현으로 두고 비즈니스 로직만 자식이 구현하게 할 때 `AbstractController`, `AbstractService` 같은 추상 클래스를 많이 사용한다.
    

## 9. 인터페이스(interface)
- 인터페이스는 “이 타입은 이런 행동을 할 수 있어야 한다”는 능력(행동) 규약만 정의하는 계약서 역할을 한다.
- 특징:
    - `interface`로 선언하며, 보통 메서드 시그니처만 정의하고 구현은 가지지 않는다(자바 8 이후에는 `default`, `static` 메서드도 가능하지만, 기본 이미지는 여전히 “행동 규약”).
    - 필드는 상수(`public static final`)만 두는 것이 일반적이고, 상태를 들고 있지 않는 것이 보통이다.
    - 한 클래스가 여러 인터페이스를 `implements`할 수 있어서 “여러 능력”을 동시에 표현할 수 있다.
- 실무 예시: `PaymentService`, `MessageSender`, `Runnable`, `Serializable` 등은 “결제할 수 있는 능력”, “메시지를 보낼 수 있는 능력”, “실행 가능한 능력”처럼 행동을 규약으로 묶어놓은 인터페이스이다.
    

## 10. 추상 클래스 vs 인터페이스 선택 기준

- 추상 클래스가 더 어울리는 경우
    - 공통 상태(필드)와 공통 구현을 실제로 물려주고 싶고, 자식들이 이 상태와 메서드를 공유하는 것이 자연스럽다.
    - 예: 공통 필드와 공통 메서드가 많은 `AbstractController`, `AbstractRepository`.
- 인터페이스가 더 어울리는 경우:
    - “이 타입은 이런 행동을 제공해야 한다”는 규약만 필요하고, 내부 상태나 구현 방식은 구현체마다 다르게 가져가고 싶을 때.
    - 예: `PaymentService`처럼 “결제를 할 수 있다”는 행위만 알면 되고, 각 결제 수단마다 상태와 로직이 달라지는 경우.
- 정리하면, 결제 예시에서처럼 공통 상태를 부모에서 정의하기 애매하고, 호출 측은 “결제를 할 수 있다”는 능력만 알면 되는 경우에는 **인터페이스가 적합**하고, 공통 상태와 구현을 명확하게 공유해야 하는 공통 부모가 있을 때는 **추상 클래스가 적합**하다.