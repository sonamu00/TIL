### 상속

- 기본의 클래스를 재사용하여 새로운 클래스 작성

- 상속의 정의와 장정
    - 장점: 코드의 재사용성 높힘, 코드의 중복을 제거하여 프로그램 생산성과 유지보수 상향
    - 주의 : 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
    - 자손 클래스의 인스턴스 생성하면 조상클래스의 멤버와 자손클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.
- 클래스 포함관계

- 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수 선언

- 클래스간의 관계 결정하기
    - is-a (상속관계)
        - 예) Circle is a figure
    - has-a (포함관계)
        - 예) Circle has a Point

### 생성자

- 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드이다.

- 기본 생성자
    - 클래스에 정의된 생성자가 하나도 없을 때 컴파일러가 기본 생성
- 매개변수 생성자
    - 인스턴스 생성하는  동시에 매개변수 값으로 초기화를 할 수 있다.
- this(), this.
    - 생성자에서 다른 생성자를 호출할 때 this()
    - 인스턴스 자신을 가르킬 때 this.

### 오버라이딩

- 조상클래스로부터 상속받은 메서드의 내용을 변경하는 것

- 오버라이딩의 조건
    - 이름이 같아야 한다.
    - 매개변수가 같아야 한다.
    - 반환타입이 같아야 한다.
    - 접근제어자는 조상클래스의 메서드보다 큰 범위로 변경해야함
    - 예외는 조상클래스의 메서드보다 적게 선언해야함
- 오버로딩과 오버라이딩의 차이점
    - 오버로딩 : 기존에 없는 새로운 메서드를 정의
    - 오버라이딩: 상속받은 메서드의 내용 변경

### super

- 상속받은 멤버를 참조하는데 사용되는 참조변수
- 쓰이는 경우
    - 조상클래스 멤버와 자손클래스 멤버가 중복 정의되어 서로 구별해야 되는 경우
    - 인스턴스 메서드에서만 사용할 수 있다.

### super()

- 조상클래스의 생성자를 호출할 때 사용
- object클래스를 제외한 모든 클래스의 생성자 첫 줄에 super()를 호출
- 호출하지 않을 경우 컴파일러가 자동적으로 넣음
- 조상 클래스의 멤버변수는 조상의 생성자로 초기화 해야하기 때문에 자손클래스 생성자 맨 첫 줄에 명시 해야함

### 다형성

- 조상 타입 참조 변수로 자손 타입 객체를 다루는 것
- 자손 타입의 참조변수로 조상 타입의 객체를 가리킬 수 없다.
    - 참조변수가 가리키는 값 보다 객체 멤버가 적으면 없는 값을 가리키게 되어서 에러
- 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
- 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수 없다(NULL값을 가르킬 수 있기 때문)

### 참조변수의 형변환

- 사용할 수 있는 멤버의 갯수를 조절하는 것
- 조상-자손 관계의 참조변수는 서로 형변환 가능
- 조상 타입 ← 자손 타입(Up-casting) : 형변환 생략가능
- 자손 타입 ← 조상 타입(Dowm-casting) : 형변환 생략불가
    - 형변환 생략 이유 : 원래 가리키는 값보다 적게 가리키면 안전하지만, 더 많이 가리키게  되면 객체에 없는 값을 가리키게 될 수 있어서 위험하기 때문에 다운캐스팅은 형변환을 명시한다.
- 형변환은 참조변수 타입만 변환하기 때문에 인스턴스에 영향이 없다.

참조변수가 가르키는 인스턴스의 멤버 갯수만 넘지 않는 것이 중요

### instanceof 연산자

- 참조변수의 형변환 가능여부 확인에 사용.
- 형변환 전에 반드시 instanceof로 확인해야 함
- 사용방법
    `참조변수 instanceof 타입(클래스명)`
    - 형변환 가능하면 true, 아니면 false를 반환하기 때문에 if문과 쓰인다.

### 다형성의 장점

- 매개변수의 다형성
    - 참조형 매개변수는 메서드 호출시, 자신과 같은 타입, 자손타입의 인스턴스를 넘김
- 여러 종류의 객체를 배열로 다루기
    - 조상타입의 배열에 자손들의 객체를 담을 수 있다.

### 추상클래스
- 개념
    - 미완성설계도, 미완성 메서드를 갖고 있는 클래스
    - 다른 클래스에 도움을 주기 위한 것이여서 인스턴스 생성 불가
    - 상속을 통해 추상 메서드를 완성해야 인스턴스 생성가능
    - 꼭 필요하지만 자손마다 다르게 구현될 것으로 예상될 때 사용
- 추상메서드
    - 선언부만 있고 구현부{}가 없는 메서드
    - 추상메서드는 호출할 때 선언부만 작성하고 선언부만 알면 자유자제로 호출가능
- 추상클래스의 작성
    - 여러 클래스에 공통적으로 사용될 수 있는 추상클래스를 바로 작성
    - 기준클래스의 공통 부분을 뽑아서 추상클래스를 만든다

### 인터페이스

- 추상 메서드의 집합
- 구현된 것이 전혀 없는 설계도, 껍데기(모든 멤버가 public)

- 인터페이스의 상속
    - 인터페이스의 조상은 인터페이스만 가능(object X)
    - 다중 상속이 가능
 
 추상클래스와 인터페이스의 차이점 : 인터페이스는 추상클래스처럼 멤버변수, 생성자, 인스턴스메서드를 가질 수 없다.

- 인터페이스를  이용한 다형성

- 인터페이스 타입 매개변수는 인터페이스를 구현한 클래스의 객체만 가능
- 인터페이스를 메서드의 리턴타입으로 지정할 수 있다. ⇒ 인터페이스를 구현한 클래스의 인스턴스를 반환

- 인터페이스의 장점

- 두 대상(객체)간의 '연결'을 돕는 '중간 역할'을 한다.
- 선언(껍데기)와 구현(알맹이)을 분리시킬 수 있게 한다.
- 개발 시간을 단축할 수 있다.
- 변경에 유리한 유연한 설계가 가능하다.
- 표준화가 가능하다.(jdbc: 인터페이스의 집합)

- 디폴트 메서드와 static 메서드

- 인터페이스에 새로운 메서드를 추가하기 까다로워서 디폴드 메서드(인스턴스 메서드)를 추가한다.
- 디폴드 메서드가 기존 메서드와 충돌할 때의 해결책 ⇒ 그냥 직접 오버라이딩한다.

### 내부 클래스

- 클래스 안의 클래스

- 내부 클래스의 장점
    - 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
        - 객체 생성없이 외부 클래스의 멤버 접근가능
    - 코드의 복잡성을 줄일 수 있다(캡슐화)
- 내부 클래스의 제어자와 접근성
    - 내부 클래스의 제어자는 변수에 사용 가능한 제어자와 동일
    - 외부 클래스의 private 멤버도 접근 가능하다.
    - 지역 내부 클래스를 감싸고 있는 메서드의 상수만 사용가능
        - constant pool에서 상수를 따로 관리하고 있어서 메서드가 종료되어도 사용할 수 있음
- 익명 클래스
    - 정의와 생성을 동시에 하고 이름이 없는 일회용 클래스
