##### ConcurrentHashMap을 쓰는 이유
- 정의: 여러 스레드가 동시에 접근해도 안전하고 조회할 때 락을 사용하지 않는 고성능 해시테이블
- 목적: 전체 Map 자체를 Lock 걸지 않고 각 버킷마다 동시성 제어해서 쓰기 병목을 분산하고, 조회할 때에는 락을 걸지 않아서 조회 성능을 높히기 위해서 사용함.
- 관련 키워드: 동시성, 전역 락, 검색 작업, 스레드 세이프, 컨텍스트 스위칭

##### ConcurrentHashMap vs HashMap
| ConcurrentHashMap   | HashMap             |
| ------------------- | ------------------- |
| 동기화 처리 O            | 동기화 처리 X            |
| 락을 버킷에만 건다          | 전체에 락 건다<br>        |
| null 사용 X           | null 사용 O           |
| 이터레이터 순회 중 데이터 변경 O | 이터레이터 순회 중 데이터 변경 X |

##### ConcurrentHashMap 동작 방식
- 읽기 작업
	- 락 없이 수행됨 (hashtable은 읽기 작업도 락 걸림)
- 쓰기 작업
	- 빈 버킷에 접근
		- **CAS (Compare-And-Swap)** 연산 사용: 메모리 위치의 현재 값이 기대값 과 같을 때만 새 값으로 바꾸는 락 없이 진행하는 연산
	- 데이터가 존재하는 버킷에 접근 (해시충돌)
		- 해당 버킷의 **첫 번째 노드(Head) 객체에만** synchronized 락을 건다 -> 해시 충돌만 버킷만 잠궈서 다른 버킷에 접근하는 스레드에는 영향 안감
