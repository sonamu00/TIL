## 프로세스와 쓰레드
![36](img/36.png)
- 프로세스가 하는 일은 자원을 할당 받고 제어해서 원하는 목적을 달성하는 것
- 프로세스를 할당, 제어로 역할을 나눌 수 있는데 여기서 제어는 쓰레드라고 한다.
- 하나의 프로세스에 쓰레드는 여러개이다.
  - 하나의 자원에 여러 제어가 있다.
## 쓰레드
- Light Weight Process(LWP)라고 부른다.
  - 자원은 공유하고 제어부분만 가지고 있어서 프로세스보다 가볍다.
- 프로세서(CPU) 활용의 기본 단위이다.
- 구성요소
  - Thread ID
  - Register set (PC, SP)
  - Stack (i.e. local data)
- 제어요소(쓰레드가 private로 가지고 있음) 외 코드, 데이터 및 자원들은 프로세스 내 다른 쓰레드들과 공유된다.
- 전통적 프로세스 == 단일 쓰레드 프로세스
![39](img/39.PNG)
- 하나의 프로세스에 쓰레드는 여러 개이다.
- 각 쓰레드는 할당받은 일을 처리한다.
- 프로세스가 할당받은 리소스는 공유한다.
### 프로세스의 메모리 공간
![38](img/38.png)
- 각 쓰레드마다 자기만의 작업영역(Stack)을 가지게 된다.
- 쓰레드는 stack에서 지역 데이터를 만들고 작업을 한다.

## 쓰레드의 장점
#### 사용자 응답성(Responsiveness)
- 일부 쓰레드의 처리가 지연되어도, 다른 쓰레드는 작업을 계속 처리할 수 있다.
#### 자원 공유(Resource sharing)
- 자원을 공유해서 효율성 증가
  - 2개 이상의 프로세스가 자원을 사용할 때 번갈아가면서 사용하는데 이 과정에서 Context switch가 발생한다.
  - Context switch는 커널이 개입하게 되고, 매우 비싼 연산이기에 피하는 것이 좋다.
  - 쓰레드는 멀티쓰레드를 사용해서 자원을 동시에 처리할 수 있다. 
#### 경제성(Resource sharing)
- 프로세스의 생성, Context switch에 비해 효율적이다.
#### 멀티 프로세서(CPU) 활용
- 병렬처리를 통해 성능 향상
  - 멀티쓰레드를 통해 여러 개의 cpu코어를 동시에 사용할 수 있다.

## 쓰레드의 구현
### 사용자 수준 쓰레드 
![40](img/40.png)
#### 사용자 영역의 쓰레드 라이브러리로 구현된다.
  - 쓰레드 생성, 스케줄링 접근 가능
  - Java thread API, POSIX threads, Win32 threads 등
#### 커널은 쓰레드의 존재를 모른다.
  - 커널의 관리를 받지 않는다.
    - 생성 및 관리 부하가 적어서 유연하게 관리할 수 있다.
    - 같은 라이브러리를 사용하는 시스템이면 여러 곳에 이식할 수 있어서 이식성(portability)이 높다.(ex: JVM)
  - 커널은 프로세스 단위로 자원을 할당한다.
    - 하나의 쓰레드가 block 상태가 되면, 모든 쓰레드가 대기한다.(single-threaded kernel의 경우)
### 커널 수준 쓰레드
![41](img/41.png)
#### OS(Kernel)가 직접 관리한다.
#### 커널 영역에서 쓰레드의 생성, 관리를 수행한다.
- Context switch 등 부하(Overhead)가 크다.
#### 커널이 각 쓰레드를 개별적으로 관리한다.
- 프로세스 내 쓰레드들이 병행 수행이 가능하다.
  - 하나의 쓰레드가 block 상태가 되어도, 다른 쓰레드는 계속 작업이 가능하다.
### Multi-Threading Model
![42](img/42.png)
### 혼합형(n:m) 쓰레드
#### 효율적으면서도 유연하다.
#### n개 사용자 수준 쓰레드 - m개의 커널 쓰레드(n > m)
- 사용자는 원하는 수만 큼 쓰레드를 사용할 수 있다.
- 커널 쓰레드는 자신에게 할당된 하나의 사용자 쓰레드가 block 상태가 되어도 다른 쓰레드를 수행할 수 있다.
  - 병행 처리 가능



