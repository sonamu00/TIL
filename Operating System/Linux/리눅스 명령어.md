

ls

-> 디렉토리 목록보기

ls [option] [directory/File]



옵션

-l : 자세히 출력

-n : numberic(숫자로) UID, GID

-d : 자기자신(디렉토리) 출력

-a : 숨김파일, 숨김 디렉토리 출력

-r : 정렬순서를 내림차순으로 출력

-R : 지정된 디렉토리에서 하위 디렉토리와 파일 모두 출력

-F : 파일형식을 기호로 나타냄 /: directory, 없음: 파일, @: 바로가기(symbolic link file), *: 실행파일

-h : 사람이 읽기 쉬운 크기로 출력

-s : 파일 크기를 기준으로 가장 큰 파일부터 정렬하여 출력

-t : 파일을 시간순으로 출력하여 최근 파일이 먼저 출력

-1 : 한줄에 하나의 파일을 출력





mkdir

-> 디렉토리 생성 명령어



옵션

-p : 하위경로까지 포함하여 생성

-m : 디렉토리의 접근권한 설정

-v : 디렉토리 생성시 메시지 출력





mount

-> 현재 마운트 상태 확인

H/W <--- driver ---> S/W <---> 사람

Driver : 중간역할(인식) : mount, 마운트하지 않으면 OS가 H/W 인식 불가



옵션

-v : 자세한 내용 출력

-f : 실제 마운트하지 않고 마운트할 수 있는지 점검

-r : 읽기만 가능 = -o ro

-w : 읽기/쓰기 가능 = -o rw

-t : 파일시스템 타입 지정(ext3, xfs, ext4, iso9660 …)

-o : 마운트 옵션을 적는다

--bind olddir newdir : 파일의 본래 위치에서 사용하면서 동시에 다른 위치에 파일 구조의 일부분을 다시 마운트 할 수 있게 함. (= olddir의 내용물을 newdir에서도 사용 가능)



마운트 옵션

Defaults rw, suid, dev, auto, nouser, async 옵션을 포함

Async 파일시스템에 대한 입출력이 비동기적으로 이루어짐

Auto -a 옵션으로 마운트 가능

Dev 파일시스템의 문자, 블록 특수장치 해석

Exec 바이너리 실행허가

Noauto -a 옵션(/etc/fstab에 있는 항목 마운트)으로 마운트 불가

Noexec 바이너리 실행 불허

Nosuid set-UID, set-GID 무시 !!사용주의 : 일부 명령어 사용불가 ex) su

Nouser 일반사용자 마운트 못함

Remount 이미 마운트된 파일시스템 재마운트 !!사용주의 : 기존께 다 날아간다...

Ro 읽기전용

Rw 읽기/쓰기

Suid set-UID, set-GID 사용

Sync 파일시스템 입출력 동기화

User 일반사용자 마운트 가능





df

-> 마운트된 hdd의 남은 용량 확인



옵션

-a : 0블록의 파일시스템을 포함(sysfs, proc), 모든 filesystem 출력

-h : 사람이 읽을 수 있는 형태로 출력

-i : i-node의 남은공간, 사용공간, 사용% 출력

-l : 출력 목록을 로컬로 제한 (nfs, isci 볼륨 등 제외)

-H : -h와 비슷하나, 1KB=1,024 Bytes 대신 1,000단위로 표시

-t : 보여주는 목록을 TYPE 제한 !!root 권한 필요 ex) -t = TYPE

-x : -t와 반대, 지정한 TYPE을 제외하고 출력 ex) -x = TYPE !!root 권한 필요





egrep

-> 동일파일에서 여러 단어를 찾을 때 편리 [정규 표현식, 확장 표현식을 사용]

Egrep [-chilnvw] 'pattern' file_name



옵션

-c : 파일이름 다음에 패턴이 있는 라인수 표시

-h : 파일이름 출력X

-i : 대소문자 구별X

-l : 매칭되는 라인이 있는 파일이름을 한번만 출력

-n : line number를 붙힘

-v : 패턴없는 라인만 출력

-w : 패턴 자체가 완전한 단일로 독립시만 글자 인식

-f : -f FILE, 파일로부터 패턴을 얻는다.

-e : -e PATTERN, 매칭할 패턴을 사용

=> or 검색은 되나 and 검색은 pipe 사용

Ex1) ABC와 XYZ가 포함된 line 검색(AND)

	Egrep "ABC"*.dat | egrep "XYZ"

Ex2) ABC 포함 혹은 XYZ가 포함(OR)

	Egrep "ABC|XYZ"*.dat

Ex3) ABC는 포함되어 있으나 XYZ가 없는 라인검색(XAND)

	Egrep "ABC"*.dat | egrep -v "XYZ"







grep



옵션

-A100 "패턴" <파일> : 패턴이후 100라인만큼 출력

-B100 "패턴" <파일> : 패턴이전 100라인만큼 출력







ps

-> 프로세스 상태 확인(process status 약자), aux, ef 옵션을 자주 사용



옵션

-l : 자세한 정보 출력 (=-f)

-u : 각 프로세스 사용자 이름/시간

-j : 작업 중심형태

-s : 시그널 중심형태

-v : 가상메모리 중심형태

-m : 메모리정보 출력

-a : 다른 사용자의 프로세스도 출력

-x : 로그인 상태동안 아직 미완료된 프로세스 출력

-S : 차일드 CPU 시간/메모리 페이지 결함(fault) 추가

-c : 커널 task_structure로부터 명령이름 출력

-e : 환경 출력

-w : 긴(wide) 형태로 출력

-h : 헤더 미출력 (PID, TTY, STAT 등…)

-r : 현재 실행중인 프로세스

-n : USER와 WCHAN을 위해 수치 출력

-o : 상태바를 지정하여 출력 가능(원하는 상태바만 sort)



상태바 설명

USER : 프로세스 사용 user

UID : 사용자 ID 

PID : 프로세스 ID

RSS : 프로세스가 사용하는 실제 메모리 양

VSZ : 가상 메모리에 적재된 프로세스의 KB단위 크기 

COMMAND : 명령어

S : 프로세스나 커널 쓰레드의 상태 

SIZE : 가상 이미지의 크기 

SZ : 프로세스의 자료와 스택 크기

STAT : 실행되고 있는 프로세스의 상태 

TIME : 현재까지 사용된 cpu 시간

TT : 프로세스 제어 터미널

%CPU : cpu 시간 백분율

%MEM : 마지막 1분 동안 프로세스가 사용한 메모리의 점유율 

START : 시작시간
STAT : 상태

CMD : 사용자가 실행한 명령 이름 

ADDR : 프로세스 스택의 세그먼트 번호 

BND : 커널 스레드가 바인드되는 프로세스의 논리 프로세스 번호 (-o 옵션) 

F : 프로세스 및 쓰레드에 관련된 항목 

LIM : 메모리에 대한 소프트 한계와 관련된 항목 

NI : 프로세스의 nice값, 낮을수록 CPU 시간이 높다 

PRI : 프로세스 스케줄링 우선순위, 낮을수록 우선순위가 높다. 

STIME : 프로세스의 시작시간 

TRS : 텍스트의 실제 메모리 크기 

TTY : 연결되어 있는 터미널 

WCHAN : 프로세스에 거주하는 커널함수 




프로세스 상태(STAT)

P : 수행가능/수행 중

T : 일시정지

D : 디스크 입출력 대기

S : 20초미만의 짧게 잠듦(sleep)

I : 20초이상 길게 잠듦(idle)

Z : 프로세스가 사라질 때 시그널 처리 문제로 완전히 소멸되지 못함





아래는 STAT 필드의 상태를 설명한 내용이다. 

-D : 디스크 입출력 대기 상태로 interrupts를 걸 수 없는 상태 

-R : 실행중 

-S : 짧은 sleep 상태 

-T : 정지상태 

-Z : 좀비상태 

-W : 상주한 페이지가 없는 프로세스 

-< : 높은 우선권 프로세스 

-N : 낮은 우선권 프로세스 

-L : 페이지가 락이 걸린 상태 







awk

-> 입력파일($1 $2 $3)을 읽어 지정된 패턴과 일치하는 패턴을 매칭시켜 해당라인을 찾는 역할 + 패턴 일치시 연산도 수행

Awk [-f 프로그램파일] [-F 필드구분자] ['패턴 {액션}'] [처리할 파일명]

Ex) awk -F ':' '{print $1 $6}' ./text.txt

	Text.txt 파일에서 ":" 구분자를 이용하여 1,6번째 필드 프린트



* 마지막 칼럼 출력

awk '{print $NF}' 파일



* 마지막 이전 칼럼 출력

cat 파일명 | awk '{print $(NF-1)}'



* 마지막 2개 칼럼 출력

awk '{print $(NF-1)"\t"$NF}' 파일



* 수식 사용 ( 구분자 'tab' 사용하여 2번째 필드=1 & 3번째 필드>=1 & 4번째 필드<=10 인 값을 test 파일에서 출력

awk -F '\t' '{if($2==1 && $3 >= 1 && $4 <=10) print }' test

	

top

-> 시스템의 전반적인 상황 실시간 모니터링

* top [옵션]



* 옵션



-a : 메모리 사용에 따라 정렬

-b : 배치 모드에서 시작

-c : 명령어 대신 명령어 라인을 보여줌

-d : 업데이트 간격을 조정

-h : 도움말

-H : 모든 개별 쓰레드가 보여짐

-i : 좀비(zombie) 또는 Idle 상태의 것들은 무시됨

-m : VIRT 대신 USED를 보고

-M : 메모리 유닛(K/M/G)을 보여줌

-n : 반복의 최대 수를 지정

-P : 지정된 프로세스 ID들만 보여줌

-s : 보안 모드로 시작

-S : 누적 시간 모드로 시작. 활성화되면 각 프로세스는 CPU를 사용한 시간과 함께 출력

-u : 지정된 유효 사용자에 의한 프로세스만 보여줌

-U : 지정된 사용자에 의한 프로세스만 보여줌. 사용자는 실제, 유효한, 저장된 및 파일시스템 UID를 의미

-v : 프로그램 라이브러리 버전을 출력





PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND



    * PID : 프로세스 ID (PID)



    * USER : 프로세스를 실행시킨 사용자 ID



    * PRI : 프로세스의 우선순위 (priority)



    * NI : NICE 값. 일의 nice value값이다. 마이너스를 가지는 nice value는 우선순위가 높음.



    * VIRT : 가상 메모리의 사용량(SWAP+RES)



    * RES : 현재 페이지가 상주하고 있는 크기(Resident Size)



    * SHR : 분할된 페이지, 프로세스에 의해 사용된 메모리를 나눈 메모리의 총합.



    * S : 프로세스의 상태 [ S(sleeping), R(running), W(swapped out process), Z(zombies) ]



    * %CPU : 프로세스가 사용하는 CPU의 사용율



    * %MEM : 프로세스가 사용하는 메모리의 사용율



    * COMMAND : 실행된 명령어





free

-> 시스템의 메모리 정보를 출력

* free [옵션]



* 옵션

-b : 메모리의 양을 바이트로 표시한다.

-k : 메모리의 양을 Kb로 표시한다.

-m : 메모리의 양을 Mb로 표시한다.

-t : 총 합을 표시한다.

-o : 버퍼 정보를 출력하지 않는다.

-s : 지정된 시간마다 계속해서 출력한다.

-V : 버전 정보를 출력한다.





w

-> 현재 접속중인 사용자들의 정보를 보는 명령어, 사용자의 작업내용을 출력



w 명령어로 알 수 있는 정보.

- 서버의 현재 시각 정보

- 서버의 부팅한 이후의 시스템 작동 시간

- 서버 접속자의 총 수

- 접속자 별 서버 평균 부하율 정보

- 접속자 별 서버 접속 계정명

- 접속자 별 접속 TTY 명

- 접속자 별 접속한 IP명

- 접속자 별 로그인 시각 정보

- 접속자 별 CPU 사용 정보 ( JCPU, PCPU 정보 )

- 접속자별 현재 사용 명령어 정보



w [옵션] [사용자]



* 옵션

 -f : 원격에서 접속한 호스트명은 출력하지 않음



 -h : 각 필드에 대한 헤더 정보를 출력하지 않음



 -s : 간략한 형식으로 정보를 출력



 -V : 버전 정보를 출력





vmstat

-> 프로세스, 메모리, 페이징, I/O블럭, CPU 활동사항 정보 출력

procs 영역 b필드 : I/O 작업을 위한 cpu가 계속 대기 -> 디스크 I/O 문제 확인

so필드 : 스왑아웃 -> 메모리 부족 의심



* proc 필드

  r : cpu 접근 대기 중인 실행 가능한 프로세스 수

  b : I/O 자원을 할당 받지 못해 블록 된 프로세스의 수



* memory 필드

  swapd : 사용된 가상 메모리의 용량

  free : 사용가능한 여유 메모리의 용량

  buffer : 버퍼에 사용된 메모리의 총량

  cache : 페이지 캐시에 사용된 메모리의 용량



* swap 필드

  si : swap-in 된 메모리의 양 (kb)

  so : swap-out 된 메모리의 양 (kb). 스왑 아웃이 지속적으로 발생하였다면 메모리 부족을 의심 해 볼수 있습니다.



* I/O 필드

  bi: 블록 디바이스로 부터 입력 블록수

  bo: 블록 디바이스에 쓰기 블록수



* system 필드

  in : 초당 발생한 interrupts의 수

  cs : 초당 발생한 context switches(문맥교환) 수



* CPU 필드

  us : CPU가 사용자 수준 코드를 실행한 시간(단위%)

  sy : CPU가 시스템 수준 코드를 실행한 시간(단위(%)

  id : idle 시간

  wa : IO wait 시간



vmstat [-V] [-n] [delay [count]]



              -V vmstat의 버젼을 보여준다



              -n 주기적으로 헤더를 출력하지 않고 단한번만 헤더 정보를 출력하게 지정한다.



              -a buff와 cache 대신 active와 inactive 메모리 사용량을 출력해준다.



              



              -----------memory-----------                       -----------memory----------



              swpd      free      buff     cache        ====>       swpd     free     inact    active



                    0    55024    85088    719004                             0   54900   616916   263876



                    



              -d 각 영역 별 디스크 사용량을 보여준다.



              -D 전체 디스크 통계를 보여주고, 단 한번만 결과를 출력해준다.



소문자 d 와 대문자 D 의 차이점은 d는 각 디스크별 결과를 제공하지만 D는 전체 디스크의 합이라고 보면 된다.



              -p diskpartition 지정한 디스크 파티션에 대한 통계 정보를 확인 할 수 있다.



              -s 부팅 시작부터 os상에서 수행된 이벤트와 메모리 사용량에대한 통계를 단 한번 출력해준다.



              -m slab에 대한 정보를 출력한다. 이 명령은 delay를 지정하면 지정된 간격으로 결과를 출력하며 -n 옵션 사용 시 결과 내 딱 한 헤더를 출력한다.



              -S unit-size 출력되는 데이터의 단위를 지정할 수 있다. 단위는 k, K, m, M 4가지가 있고,



각각 k:1000, K:1024, m:1000000, M:1048576 으로 나눈 값을 출력해준다.



              delay [count] 결과의 출력 주기를 의미한다. 이 값을 지정하지 않으면 한번만 수행되고 종료된다. 





sar

1. sar 명령으로 확인할 수 있는 내용



  - I/O 전송량

  - 페이징

  - 프로세스 생성 숫자

  - 블락 디바이스 활동

  - 인터럽트

  - 네트워크 통계

  - run 큐 및 시스템 부하 평균

  - 메모리와 스왑 공간 활용 통계

  - 메모리 통계

  - CPU 이용도

  - 특정 프로세스에 대한 CPU 이용도

  - inode, 파일, 기타 커널 테이블에 대한 상태

  - 시스템 스위칭 활동(context switch)

  - 스와핑 통계 - 특정 프로세스 통계

  - 특정 프로세스의 자식 프로세스 통계

  - TTY 디바이스 활동



2. sar 옵션

sar -A : 모든 정보를 출력

%user : 사용자 레벨(application level)에서 실행중일때의 CPU 사용률

%nice : 사용자 레벨(appliaction level) 에서 nice 가중치를 준 CPU 사용률

%system : 시스템레벨(kernel) 에서 실행중일때의 CPU 사용률(%) 

%iowait : system이 I/O요청을 처리하지 못한 상태에서의 CPU의 idle 상태인 시간의 비율

%steal : virtual processer에 의한 작업이 진행되는 동안 virtual CPU에 의해 뜻하지 않는 

         대기시간이 생기는 시간의 비율 

%idle : CPU가 쉬고있는 시간의 비율



sar 5 2 : 5초 간격으로 2회 수행



sar -b : 버퍼의 activity를 점검하여 I/O와 transfer의 통계를 출력

tps: 물리적 디스크에서 발생한 초당 전송량이며, 

     여기서의 전송은 물리적 디스크에 요청한 I/O

rtps: 물리적 디스크로부터 발생된 초당 읽기의 총 요청 횟수.

bread/s: 드라이브 안의 블럭에서 초당 읽은 데이터의 총합.

bwrth/s: 드라이브 안의 블록에서 초당 쓰여진 데이터의 총합.



sar -r : 가용메모리 점검 및 메모리 공간 통계 출력



sar -R : 메모리 통계 보기

frmpg/s : 시스템에서 초당 자유로워진 memory pages 의 양 페이지의 크기는 시스템 아키텍쳐

          에따라  달라지며 보통 4K / 8K 임. 

bufpg/s : 시스템에서 초당 buffer 에 추가적으로 더해진 memory pages 의 양  

campg/s : 시스템에서 초당 system에 의해 cache된 memory pages 의 양





echo

-> 리눅스 명령어 echo는 주어진 문자열을, 문자열 사이에 포함된 공백과 줄 마지막에 개행문자를 포함하여 표준출력으로 출력하는 명령어다.



echo [옵션]... [문자열]...

-n : 마지막에 따라오는 개행 문자(newline) 문자를 출력하지 않음



-e : 문자열에서 역슬래시(\)와 조합되는 이스케이프 문자(escape sequence)를 인용





find

-> 사용법 : find [검색대상위치] [옵션] [수행할작업]



[옵션]

-empty : 비어 있는 파일, 단 일반파일 또는 일반 디렉토리에 한함

-uid n : 지정된 n값의 UID를 갖는 파일

-gid n : 지정된 n값의 GID를 갖는 파일

-group 그룹명 : 지정한 그룹명에 소속된 파일

-name : 지정된 형식의 패턴을 가지는 파일

-newer 파일 : 지정한 파일보다 더 최근에 변경된 적이 있는 파일

-used n : 파일이 변경된 이후 최근 n일 이후에 액세스된 적이 있는 파일

-user uname : 지정한 uname의 소유로 된 모든 파일(UID로 지정가능)

-amin n : 최근 n분 이전에 액세스된 적이 있는 파일

-anewer 파일 : 지정한 파일보다 더 최근에 액세스된 적이 있는 파일

-atime n : 최근 n*24 시간 전에 액세스된 적이 있는 파일

-mmin n : 최근 n분 이전에 변경된 적이 있는 파일

-mtime n : 최근 n*24 시간 이전에 변경된 적이 있는 파일

-executable : 실행 가능한 파일

-readable : 읽기 가능한 파일

-writable : 쓰기 가능한 파일

-fstype type : 지정한 파일시스템타입(type)에 존재하는 파일

-nogroup : 소속그룹이 존재하지 않는 파일

-nouser : 소속 사용자(ID)가 존재하지 않는 파일

-path 패턴 : 파일명이 패턴에 매칭되는 파일

-perm 모드 : 모드에서 지정된 퍼미션과 일치하는 퍼미션을 가진 파일만 해당됨.

-perm -mode : 모드에서 지정된 퍼미션을 가진 모든 파일.

-regex 패턴 : 패턴에서 지정한 정규표현식에 매칭되는 파일

-size n[cwbkMG] : 지정된 n 단위의 디스크공간을 사용하는 파일. 디폴트는 b

-type 타입 : 지정한 파일타입에 해당하는 파일. b,c,d,p,f,l,s 등이 있음



위의 n 값은 +n 은 n 보다 큰 값을 의미하고, -n 은 n 값보다 작은 값을 의미하며, n 은 정확하게 n 값만을 의미한다.



[수행할작업(action)]

-delete : 검색된 파일들을 삭제

-exec command ; : 지정한 command 를 실행

-exec command {} + : 검색된 파일들을 차례대로 매칭하면서 지정된 command 를 수행

-ls : 'ls - dils' 를 수행

-ok command ; : -exec 와 같지만 실행하기 전에 먼저 사용자에게 표준입력으로 수행할 command 를 입력 받는다. 만약 입력이 없다면 지정된 command 를 수행한다.

-print : 검색된 파일들에 대하여 전체파일 경로로 파일리스트를 표준출력으로 출력한다.

-printf format : 검색된 파일들에 대하여 지정된 format 형식으로 표준출력으로 출력



[연산자]

( ) : 괄호( )안의 연산이 먼저 행해짐

! expr : expr 이 거짓일때 참, 참일때 거짓이 됨.

-not expr : 위의 ! expr 과 동일함 (POSIX 호환용)

expr1 expr2 : AND 의 의미. expr1 이 거짓일 때에는 expr2 는 평가되지 않음

expr1 -a expr2 : 'expr1 expr2' 와 같음

expr1 -and expr2 : 'expr1 expr2' 와 같음 (POSIX 호환용)

expr1 -o expr2 : OR 의 의미. expr1 이 참일 경우 expr2 는 평가되지 않음.

expr1 -or expr2 : 'expr1 -o expr2' 와 같은 의미





 chmod



사용법

chmod [options] mode[,mode] file1 [[file2 ...]] 



옵션



-c : 실제로 파일의 권한이 바뀐 파일만 자세히 기술한다.

-f : 파일의 권한이 바뀔 수 없어도 에러 메시지를 출력하지 않는다. 

-v : 변경된 권한에 대해서 자세히 기술한다.

 -R : 하위 디렉토리 권한을 재귀적으로 모두 바꾼다.  ※제일 많이 쓰이는 옵션이다.



r(read 읽기), w(write 쓰기), x(execute 실행)의 3가지 권한이 있다.

읽기, 쓰기, 실행 등의 모든 권한을 주려면, 4+2+1, 따라서 합계 7이된다.

 만약 모든 그룹의 권한을 다 허용해 줄 경우, 777이 된다.



대상

u : user의 권한 g : group의 권한 o : other의 권한 a : 모든 사용자 권한

+/-/=+ : 해당 권한을 추가한다.

– : 해당 권한을 제거한다.

= : 해당 권한을 설정한대로 변경한다.





sort



옵션

정렬 옵션-b: 선행 공백 무시한다.

-f: 영어 소문자를 대문자로 처리한다. 즉, 대소문자 구별안한다.

-n: 비교 대상을 텍스트내의 숫자로 한정하여 정렬한다.

-R: 해시의 키값 기준으로 랜덤하게 정렬한다.

-r: 비교 결과를 역순(내림차순)으로 정렬한다.

확장 옵션 -c: 파일이 정렬되어 있는지 검사한다.

-k n: n번째 필드를 기준으로 정렬한다.

-m: 이미 정렬된 파일들을 병합한다. (정렬은 하지 않는다.)

-o: 표준 출력 대신 저장할 파일명을 명시한다.

-t: 필드 구분자를 지정해준다. (기본 구분자는 공백이다.)

-u: 정렬 후 중복된 내용을 제거한다.



sort 사용 예)

현재 디렉터리를 파일 크기에 따라 정렬하기

$ ls -s | sort -n  96 Nov1.txt 128 _arch_backup.lst 128 _arch_backup.lst.tmp1708 NMON



알파벳 순서로 파일 정렬하기

$ cat phonebookSmith, Brett     555-4321Doe, John        555-1234Doe, Jane        555-3214Avery, Cory      555-4321Fogarty, Suzie   555-2314

$ sort phonebookAvery, Cory      555-4321Doe, Jane        555-3214Doe, John        555-1234Fogarty, Suzie   555-2314Smith, Brett     555-4321



숫자로 정렬하기

-n 옵션은 프로그램이 숫자값에 따라 정렬되도록 만든다:

$ du /bin/* | sort -n4       /bin/domainname24      /bin/ls102     /bin/sh304     /bin/csh

$ cat zipcodeAdam  12345Bob   34567Joe   56789Sam   45678Wendy 23456

$ sort -nk 2 zipcodeAdam  12345Wendy 23456Bob   34567Sam   45678Joe   56789



파이프로 한정된 파일 정렬하기

$ sort -t':' -k2 zipcodeAdam|12345Wendy|23456Bob|34567Sam|45678Joe|56789



반대로 정렬하기-r 옵션은 단순히 정렬하기 순서를 반대로 뒤집는다:

$ sort -nrk 2 zipcodeJoe   56789Sam   45678Bob   34567Wendy 23456Adam  12345





uniq



#uniq [옵션] [파일명]



-c : 중복횟수를 중복 행과 함께 보여준다.

-D : 중복되는 모든 행을 출력합니다.

-u : 중복되지 않는 행만 출력합니다.

-d : 중복되는 행만 출력합니다.

-i : 행 비교시 대소문자 구별을 하지 않는다.

-s수 : 한행에서 지정된 수만큼 문자를 비교대상에서 제외한다.

-f수 : 맨 앞에서부터 지정된 수만큼 필드를 비교대상에서 제외한다.

-w수 : 비교대상 문자수를 지정



예)한 예로 어떤 파일에 중복되는 내용의 행을 정렬하고 중복횟수를 세어 오름차순 정리한다면,

$ sort file | uniq -c | sort -n 위와 같이 적용하면 된다. 셸 스크립트에서 파이프라인을 삽입하여 uniq를 sort와 함께 실행하는 것이다. 여기서 주의해야 할 점은 uniq는 파일 내용이 미리 정렬되어 있는 상태에서 실행할 수 있다.



$ cat fruits.txtorangeappleappleorangeorangeapple

$ uniq -c fruits.txt1 orange2 apple2 orange1 apple

정렬이 이루어지지 않은 상태에서 uniq를 적용하였기에 위와 같은 결과를 얻을 수 있다.



$ sort -u fruits.txtappleorange

이것은 파일내용을 정렬시켜 중복되는 것을 하나로 표현하는 것이다. 결론적으로 uniq는 파일에 전체적으로 분산된 중복을 한번에 잡아내지 못한다. 따라서 정렬하여 순차적으로 만든 뒤에 적용한다.





du



1. 기능

du 는 Disk Usage를 의미하며, 지정된 디렉토리의 디스크 사용량을 표시하는 명령어 입니다. 



2. 형식

# du [ 옵션 ] [ 파일 ] [ 디렉토리]



3. 옵션

-a : 디렉토리가 아닌 모든 파일에 대한 정보를 출력

-k : 결과 값을 KB 단위로 출력(기본값)

-m : 결과 값을 MB 단위로 출력

-h : 사용자가 이해하기 쉬운 용량의 단위(KB,MB,GB)를 표시(1M를 1,048,576단위로 계산)

-H : 사용자가 이해하기 쉬운 용량의 단위(KB,MB,GB)를 표시(1M를 1,000,000단위로 계산)

-i : i-node의 사용정보를 표시함

-l : 하드 링크의 용량을 모두 계산함

-s : 사용량의 총 합계만 출력 함

-S : 하위 디렉토리를 합치지 않고, 각각을 나누어서 계산하며

지정된 디렉토리 내의 파일과 모든 하위 디렉토리의 용량, 내용까지 볼 수 있음.

-T :  각 파일시스템들이 사용하고 있는 파일시스템 종류를 추가로 표시해 줌



4. 기타 사용예)

1). 디스크사용량을 출력할 때에 파일시스템의 종류와 함께 표시하기

# df -T



2). 디렉토리별로 집계해서 용량순으로 표시하기

# du -S | sort -n



3). 지정한 디렉토리만 표시하기

# du -h -s 디렉토리



4). GB이상의 디렉토리를 표시하기

# du -h | grep [0-9]G





uname

지정된 시스템 정보를 출력한다. 옵션이 없을 경우 -s옵션과 같은 결과를 보여준다. -a, --all 모든 정보를 보여준다. 아래의 모든 옵션을 사용한 것과 동일한 효과



-s, --kernel-name 커널 이름을 출력한다.

-n, --nodename 네트워크 노드에서의 호스트 이름을 출력한다.

-r, --kernel-release 커널 release 번호를 출력한다.

-v, --kernel-version 커널 버전번호를 출력한다.

-m, --machine 하드웨어 이름을 출력한다.

-p, --processor 프로세서 타입을 출력한다.

-i, --hardware-platform 하드웨어 플렛폼정보를 출력한다.

-o, --operating-system 운영체제 정보를 출력한다.



# uname -aLinux yundream-desktop 2.6.15-27-386 #1 PREEMPT Sat Sep 16 01:51:59 UTC 2006 i686 GNU/Linux





stat

-> stat명령을 이용하면 atime, mtime, ctime 정보를 동시에 확인할 수 있다.

atime : 파일접근시간(파일open시 갱신)

ctime : 파일권한,파일크기 변경시 ctime 갱신

mtime : 파일수정시간(mtime 변경시(파일내용 수정시) ctime,atime 모두 변경)



형식 : stat [OPTION] FILE...



access : 해당 파일을 실행한 시점

change : 해당 파일의 소유권 및 퍼미션이 변경된 시점

modify : 해당 파일의 내용이 변경된 시점



-l : 링크 파일의 소스 파일 정보를 보여준다.

-f : 파일명이 있는 파일시스템의 정보를 보여준다.

-v :  버전 정보

-t : 간략한 정보



%a Access rights in octal

%A Access rights in human readable form

%b Number of blocks allocated (see %B)

%B The size in bytes of each block reported by %b

%d Device number in decimal

%D Device number in hex

%f Raw mode in hex

%F File type

%g Group ID of owner

%G Group name of owner

%h Number of hard links

%i Inode number

%n File name

%N Quoted file name with dereference if symbolic link

%o I/O block size

%s Total size, in bytes

%t Major device type in hex

%T Minor device type in hex

%u User ID of owner

%U User name of owner

%x Time of last access

%X Time of last access as seconds since Epoch

%y Time of last modification

%Y Time of last modification as seconds since Epoch

%z Time of last change

%Z Time of last change as seconds since Epoch

Valid format sequences for file systems:

%a Free blocks available to non-superuser

%b Total data blocks in file system

%c Total file nodes in file system

%d Free file nodes in file system

%f Free blocks in file system

%C Security context in SELinux

%i File System ID in hex

%l Maximum length of filenames

%n File name

%s Block size (for faster transfers)

%S Fundamental block size (for block counts)

%t Type in hex

%T Type in human readable form



***파일 접근시 atime변경이 되지 않는 이유

https://www.lesstif.com/pages/viewpage.action?pageId=20776621

-> 요약 : 일반적으로 웹서버 등 File IO가 많이 일어나는 경우, File에 대한 read 연산이많이 일어나게 된다. 이때 IO성능저하를 유발할 수 있으므로 mount 시 noatime 옵션을 준다.kernel 2.6.30 부터는 realtime(파일 status 변경시, mtime보다 atime이 예전일 시만 atime 기록)을 기본옵션으로 탑재한다. /etc/fstab을 확인해보자!





ngrep

-> ngrep은 접속 호스트별, 포트별, 장비별 패킷 확인이 가능하다.



사용법ngrep [옵션] [매칭할 패턴] [ BPF 스타일 Filter ]



옵션

-t : 시간도 함께 표시

-x : 16진수와 함께 표시

-d device : 디바이스를 지정할 때

-i : 대소문자를 무시한다.



- 특정 IP의 80 포트로 통신하는 패킷 확인 방법 

# ngrep -v -qt host 123.123.123.124 and port 80 - 오라클(특정 포트 : 1521)로 전송되는 SQL 등을 확인할 때# ngrep -qx dest port 1521



- 특정 IP의 80 포트를 제외한 패킷 확인 방법

# ngrep -v -qt host 123.123.123.124 and not port 80



fake.pcap 에서 GET 이 들어가 있는 문구를 찾는다.

# ngrep -I fake.pcap GET



-x 옵션은 ASCII 뿐만 아니라 HEX 형태로도 출력을 보여주는 것이고 -X 는텍스트 패턴 매칭이 아니라 HEX 값으로 패턴 매칭을 해준다.

# ngrep -I fake.pcap -xX '0x4d5a' port 80



이외 정규 표현식을 사용하여 효과적으로도 쓸수 있는데, 아래 예는 GET, POST, HEAD, CONNECT가 들어가 있는 패턴만을 찾는 것이다. 찾을때는 -d 옵션으로 디바이스인 eth0 을 지정했다.

# ngrep -qd eth0 '^(GET|POST|HEAD|CONNECT)' 'tcp'



이외 -O 옵션을 통해 pcap 파일로 저장이 가능하다.

# ngrep -O test.pcap port 80



* 특정 IP로 오가는 패킷중 80포트는 재외

# ngrep -v -qt host IP and not port 80



* Codered 패킷을 볼 때

# ngrep -iqt 'default.ida' port 80



* 특정 호스트로 오고가는 메일, FTP, 텔넷 작업 확인

# ngrep -qx host IP and port 25 or port 110 or port 21 or port 23



* 오라클 리스너로 가는 패킷 확인 (프로그램에서 던져지는 SQL문 확인시 유용)

# ngrep -qx dst port 1521



- 특정 패턴이 있는 패킷만 스니핑 할 수도 있습니다.

# ngrep 'HTTP' -d eth0 -t port 80





tcpdump



Tcpdump의 옵션들

-a : Network & Broadcast 주소들을 이름들로 바꾼다. 

-c Number : 제시된 수의 패킷을 받은 후 종료한다. 

-d : comile된 packet-matching code를 사람이 읽을 수 있도록 바꾸어 표준 출력으로 출력하고, 종료한다. 

-dd : packet-matching code를 C program의 일부로 출력한다. 

-ddd : packet-matching code를 숫자로 출력한다. 

-e : 출력되는 각각의 행에 대해서 link-level 헤더를 출력한다. 즉 맥어드레스를 함께 출력한다. 

-f : 외부의 internet address를 가급적 심볼로 출력한다(Sun의 yp server와의 사용은 가급적 피하자). 

-F file : filter 표현의 입력으로 파일을 받아들인다. 커맨드라인에 주어진 추가의 표현들은 모두 무시된다. 

-i device : 어느 인터페이스를 경유하는 패킷들을 잡을지 지정한다. 지저되지 않으면 시스템의 인터페이스 리스트를 뒤져서 가장 낮은 번호를 가진 인터페이스를 선택한다(이 때 loopback은 제외된다). 

-l : 표준 출력으로 나가는 데이터들을 line buffering한다. 다른 프로그램에서 tcpdump로부터 데이터를 받고자 할 때, 유용하다. 

-n : 모든 주소들을 변환하지 않는다(port, host address 등등) 이것은 DNS lookup을 피할 수 있다. 

-nn : protocol 과 port를 이름으로 변환하지 않는다. 

-N : 호스트 이름을 출력할 때, 도메인을 찍지 않는다. 

-O : packet-matching code optimizer를 실행하지 않는다. 이 옵션은 optimizer에 있는 버그를 찾을 때나 쓰인다. 

-p : 인터페이스를 promiscuous mode로 두지 않는다. 

-q : 프로토콜에 대한 정보를 덜 출력한다. 따라서 출력되는 라인이 좀 더 짧아진다. 

-r file : 패킷들을 '-w'옵션으로 만들어진 파일로 부터 읽어 들인다. 파일에 "-" 가 사용되면 표준 입력을 통해서 받아들인다. 

-s length: 패킷들로부터 추출하는 샘플을 default값인 68Byte 외의 값으로 설정할 때 사용한다(SunOS의 NIT에서는 최소가 96Byte이다). 68Byte는 IP,ICMP, TCP, UDP등에 적절한 값이지만 Name Server나 NFS 패킷들의 경우에는 프로토콜의 정보들을 Truncation할 우려가 있다. 이 옵션을 수정할 때는 신중해야만 한다. 이유는 샘플 사이즈를 크게 잡으면 곧 패킷 하나하나를 처리하는데 시간이 더 걸릴 뿐만아니라 패킷 버퍼의 사이즈도 자연히 작아지게 되어 손실되는 패킷들이 발생할 수 있기 때문이다. 또, 작게 잡으면 그만큼의 정보를 잃게되는 것이다. 따라서 가급적 캡춰하고자 하는 프로토콜의 헤더 사이즈에 가깝게 잡아주어야 한다. 

-T type : 조건식에 의해 선택된 패킷들을 명시된 형식으로 표시한다. type에는 다음과 같은 것들이 올 수 있다. 

rpc(Remote Procedure Call), rtp(Real-Time Applications protocol), rtcp(Real-Time Application control protocal), vat(Visual Audio Tool), wb(distributed White Board) 

-S : TCP sequence번호를 상대적인 번호가 아닌 절대적인 번호로 출력한다. 

-t : 출력되는 각각의 라인에 시간을 출력하지 않는다. 

-tt : 출력되는 각각의 라인에 형식이 없는 시간들을 출력한다. 

-v : 좀 더 많은 정보들을 출력한다. 

-vv : '-v'보다 좀 더 많은 정보들을 출력한다. 

-vvv : '-vv'보다 좀 더 많은 정보들을 출력한다. 실제로 사용할 일은 많지 않다. 

-w : 캡춰한 패킷들을 분석해서 출력하는 대신에 그대로 파일에 저장한다. 

-x : 각각의 패킷을 헥사코드로 출력한다.



# tcpdump -i eth0				=> 인터페이스 eth0 을 보여줌

# tcpdump -w tcpdump.log		=> 결과를 파일로 저장, txt 가 아닌 bin 형식으로 저장됨

# tcpdump -r tcpdump.log		=> 저장한 파일을 읽음

# tcpdump -i eth0 -c 10			=> 카운터 10개만 보여줌

# tcpdump -i eth0 tcp port 80		=> tcp 80 포트로 통신하는 패킷 보여줌

# tcpdump -i eth0 tcp port 80		=> tcp 80 포트로 통신하는 패킷 보여줌

# tcpdump -i eth0 src 192.168.0.1	=> source ip 가 이것인 패킷 보여줌

# tcpdump -i eth0 dst 192.168.0.1	=> dest ip 가 이것인 패킷 보여줌

* and 옵션으로 여러가지 조건의 조합 가능

# tcpdump -i eth0 src 192.168.0.1 and tcp port 80	=> source ip 가 이것이면서 tcp port 80 인 패킷 보여줌

# tcpdump -i eth0 dst 192.168.0.1	=> dest ip 가 이것인 패킷 보여줌

# tcpdump host 192.168.0.1		=> host 를 지정하면, 이 ip 로 들어오거가 나가는 양방향 패킷 모두 보여줌

# tcpdump src 192.168.0.1		=> host 중에서 src 가 이것인것 만 지정

# tcpdump dst 192.168.0.1		=> host 중에서 dst 가 이것인것 만 지정

# tcpdump net 192.168.0.1/24		=> CIDR 포맷으로 지정할 수 있다.

# tcpdump tcp				=> TCP 인것만

# tcpdump udp				=> UDP 인것만# 

tcpdump port 3389			=> 포트 양뱡항으로 이것인 것.

# tcpdump src port 3389			=> src 포트가 이것인 것.

# tcpdump dst port 3389			=> dst 포트가 이것인 것.

* combine : and ( && ) , or ( || ) , not ( ! ) 으로 여러가지를 조합해서 사용 가능

# tcpdump udp and src port 53	=> UDP 이고 src 포트가 53 인 것

# tcpdump src x.x.x.x and not dst port 22	=> src ip 가 x.x.x.x 이고 dst 포트가 22 가 아닌 것

* grouping : ( )# tcpdump 'src x.x.x.x and ( dst port 3389 or 22 )'	=> src ip 가 x.x.x.x 이고 ( dst 포트가 3389 또는 22 ) 인 것  ==> 여기서는 ' ' 가 반드시 있어야 한다.





서버 셧다운 명령어



1. shutdown



옵션-r : 종료 후 재부팅 



-h : shutdown 이 완료된 후 시스템을 종료 

-c : 진행중인 shutdown 명령을 취소

-k : 경고 메시지만 출력하고, 실제로는 shutdown 을 하지 않음

-f : 재부팅 할 때 fsck 명령어를 건너띄고, 부팅을 빠르게 진행

-n : init를 호출하지 않고, shutdown을 진행함

-t sec : 지정시간에 시스템을 재시동



shutdown의 경우 옵션을 사용하지 않으면 기본값으로 종료가 아닌 유지보수 모드로 들어가게 됩니다. shutdown now는 시스템 종료가 아닌 유지보수 모드로 들어가는 명령입니다. 아래 나오는 'init 1'과 동일한 명령입니다.



2. init 0 : 종료모드

1 : 단일 사용자 모드(시스템 복구 시 사용)

2 : 다중 사용자 모드 (NFS 사용 불가로 서버와 공유 안됨. 인터넷도 안됨)

3 : 다중 사용자 모드 (텍스트 로그인)

4 : 사용 안 함

5 : 다중 사용자 모드 (X윈도우 로그인)

6 : 재가동 모드(재부팅)

init 런레벨은 /etc/inittab 에 정의되어 있어 수정이 가능합니다.(실제 수정 금지)



3. halt





fdisk

a       부트 가능한 플래그로 변경

b       bsd 디스크 레이블을 편집

c       도스 호환 플래그로 변경

d       파티션 삭제

l       알려진 파티션 형태의 목록

m       이 메뉴를 출력

n       새로운 파티션 추가

o       새로운 도스 파티션 테이블을 생성

p       파티션 테이블을 출력

q       변경을 저장하지 않고 종료

s       새로운 Sun 디스크 레이블을 생성

t       파티션의 시스템 id를 변경

u       표시/엔트리 단위를 변경

v       파티션 테이블을 점검

w       디스크에 테이블을 기록하고 빠져나감



옵션

-l : 현재 디스크 및 파티션 보기





mkfs



사용법 : mkfs [옵션] [장치이름]



옵션



-V : 실행되는 모든 파일 시스템 특정 명령어들을 포함하여 상세한 정보를 출력한다. 이 옵션이 한번 이상 사용되면 특정 파일 시스템을 생성하는데 사용될 프로그램의 정보만 보여주고 실질적으로 실행되지는 않는다.

-t : 생성할파일 시스템의 형식을 선택한다. ext3, xfs, reiserfs, ext2, msdos 등으로 지정하지 않으면 기본 파일 시스템인 ext3가 지정된다.

-c : 배드블럭을 조사하고 조사한 경과에 따라 배드블럭 리스트를 초기화한다.

-l : filename이라는 파일로부터 초기의 배드블럭 리스트를 읽어 들인다.

-v : 현재 진행 상황에 대해 자세히 출력한다.





fsck

fsck, e2fsck 명령어는 리눅스 파일 시스템 점검 및 복구를 할 수 있는 명령어 입니다.

e2fsck는 fsck의 확장 명령어라고 할 수 있으며 fsck 명령어에 -t 파일 시스템(ex: ext4) 옵션을 붙인 것과 동일한 명령어 입니다.

리눅스에서 사용 가능한 거의 모든 종류의 파일 시스템의 점검과 복구를 할 수 있습니다.

fsck 명령어를 사용하여 파일 시스템을 점검할 때에는 파티션을 언마운트 후 실행해야 합니다.

언마운트 하지않고 실행하면 파일 시스템에 손상이 가고 심각한 오류를 초래할 수 있습니다.



옵션

-f : 파일 시스템이 이상 유무에 상관없이 강제적으로 파일 시스템을 체크

-j : 저널링 파일 시스템을 대상으로 작업 할 때 사용 하며 필수로 해줘야 하는 옵션

-v : 점검 내역 상세 보기(ext4의 파일 시스템으로 구성된 sda2파티션을 강제로 점검하면서 상세 내역도 보는 명령)

-p : 사용자의 의견을 묻지 않고, 자동으로 파일 시스템을 체크

-y : 파일 시스템을 읽기 전용으로 열고, 수행 과정의 질문에 모두 yes라 응답하는 옵션

-n : 파일 시스템을 읽기 전용으로 열고, 수행 과정의 질몬에 모두 no 로 응답하는 옵션





rm

사용법 : rm [옵션] 파일명

-d : 하위 디렉토리 삭제

-f : 확인 없이 삭제

-i : 파일이나 디렉토리가 삭제 될 때마다 확인

-r : 하위 디렉토리를 찾아가며 삭제

-v : 삭제작업 상태를 출력





lsof

COMMAND : 실행한 명령어

PID : process id

USER : 실행한 사용자

FD: File Descriptor, 파일의 종류. 

	cwd: current working directory

	rtd: root directory

	mem : memory-mapped file

	txt: program text (code and data);

TYPE: 파일 종류

	DIR: 디렉터리

	CHR:  character special file

	REG: regular file

	unix: 유닉스 도메인 소켓 (MySQL 등이 사용하는 소켓으로 로컬 프로세스에서만 사용 가능하며 TCP/UDP 보다 속도가 매우 빠름)

DEVICE : 장치 번호

SIZE/OFF: 파일의 크기나 오프셋

NODE: 노드 번호

NAME:  파일명



옵션

-u : 특정사용자 지정

-n : 호스트이름 대신에 IP address를 출력한다.

-i [TCP/UDP:PortNumber] : 해당 프로토콜의 포트를 사용하는 프로세스 정보 확인

-p PID : 해당 PID가 오픈한 파일 표시

-c 명령어 : 특정 명령어가 열은 파일 보기

+D 디렉토리 : 티렉토리 하위의 열린 파일을 표시





/proc

/proc/cpuinfo : CPU 정보

BegoMIPS는 MIPS 정보를 보여준다. 즉 현재 CPU는 719.25 MIPS란 의미이며 다 알겠지만 초당 719.25 백만개의 명령어를 실행할 수 있다는 의미이다.

이 외에도 Cache 메모리와 관련된 정보나 Board 정보도 간단하게 확인이 가능하다.



/proc/devices : 시스템이 사용하는 디바이스 정보

크게 Char형 장치와 Block형 장치로 구분하여 보여줌을 알 수 있다.

앞에 숫자는 디바이스 드라이버의 Major 넘버이다. 현재 시스템에서 사용하는 디바이스 드라이버들은 /dev 에서 관리하는데 위의 정보와 /dev 정보를 비교해 보면 같다는 것을 알수 있다. (Minor 넘버까지 표시되므로 dev 내용이 더 많기는 하다)



/proc/filesystems : 커널이 지원하는 파일시스템의 정보



/proc/dma : DMA 채널 정보



/proc/interrupts : 인터럽트 정보, 즉 인터럽트 번호에 어떤 인터럽트가 연결되어 있는지를 알 수 있다.



/proc/ioports

사용하고 있는 입출력 포트 정보를 보여준다. 현재 내 안드로이드 환경에서는 아무 내용이 없다.

이는 x86 계열처럼 메모리 공간과 I/O 공간이 분리되어 있는 경우에 볼 수 있는 정보이기 때문이다.

현재 CPU가 ARM 계열이기 때문에 내용이 없는 것이다.



/proc/iomem

I/O 장치들이 사용하고 있는 메모리 번지를 보여준다.

x68 계열이나 ARM 계열들은 memory mapped I/O를 지원하기 때문에 이에 대한 정보를 확인할 수 있다.



/proc/kcore : 커널 메모리 이미지 출력



/proc/kmsg

커널이 동작 중 중요한 이벤트가 생기면 출력되는 메시지를 보여준다.

보통 커널에서 printk를 사용해서 콘솔에 출력하도록 한 메시지를 말한다.

이런 메시지를 확인하는 명령으로 dmesg가 있다.

원래 dmesg를 실행하면 /var/log/dmesg 의 내용을 보여준다.



/proc/ksyms

/proc/kallsyms

모듈이 참조할 수 있는 커널 내부의 함수나 변수의 심볼 정보를 가지고 있다. 이는 모듈 개념을 지원하기 위한 중요한 정보이다.

일반적으로 linux에서는 /proc/ksyms가 심볼 정보를 가지고 있다.



/proc/loadavg : 시스템의 평균 부하



/proc/meminfo : 메모리 정보, 주메모리의 크기나 사용량, 가상 메모리, 동적으로 할당된 메모리의 크기 등을 알 수 있다.



/proc/modules : 현재 커널에 적재된 모듈 정보 = lsmod



/proc/net : 네트워크 포로토콜 정보, 커널이 지원하는 각종 프로토콜의 현재 상황에 대한 정보를 가진 파일들을 확인할 수 있다.



/proc/stat : 커널과 시스템 정보



/proc/sys : 커널이 사용중인 커널 변수정보를 가지고 있는 디렉토리.



/proc/uptime : 시스템 가동시간 출력



/proc/version : 커널 버전 정보



/proc/pci

/proc/scsi

시스템에 있는 PCI와 SCSI 디바이스들의 정보





/proc/번호

번호는 디렉토리이다. 이 번호는 PID(Process ID)를 의미한다. 보통 터미널에서 ps 명령어를 치면 보여지는 내용을 만들 때 이 번호 디렉토리의 내용을 이용한다.



간단히 내용을 정리하면 다음과 같다.



cmdline : 프로세스를 실행한 명령어를 모두 보여준다.

environ : 이 프로세스가 참조하는 환경변수 정보를 갖고 있다.

fd : 프로세스가 참조하는 파일 목록 정보, 파일명이 0 부터 시작되어 링크된 파일을 확인한다.

maps : 현재 프로세스가 사용하고 있는 메모리 구역 정보인데 주로 보면 lib가 로딩된 메모리 위치를 확인할 수 있다.

stat, statm, status : 프로세스의 상태 정보들을 담고 있다. stat는 프로세스의 상태를 statm은 프로세스의 메모리 상태, status는 사람이 보기 편한 형태로 프로세스의 상태를 나타낸다.

mem : 프로세스가 억세스 하는 메모리 (?)

root : 프로세스의 루트 디렉토리  (심볼릭 링크)

cwd : 프로세스의 작업 디렉토리  (심볼릭 링크)

exe : 이 프로세스를 실행한 바이너리 (심볼릭 링크)





ifconfig

사용법 : ifconfig [인터페이스] 또는 ifconfig [인터페이스] [타입] [옵션]



[옵션]

-a : 모든 네트워크 정보를 볼 수 있음

up : 지정한 인터페이스를 활성화

down : 지정한 인터페이스 비활성화

netmask addr : 넷마스크 설정

address : 인터페이스에 IP주소를 설정



예)

ifconfig 인터페이스 up/down



IP 변경

ifconfig 인터페이스 IP IP주소 netmask 넷마스크 broadcast 브로드캐스트주소



Promisc 모드 on

Ifconfig eth0 promisc



Promisc 란?

	1. 패킷을 무조건 수용하는 모드

	2. 네트워크 카드의 동작방식 모드 중 하나

	3. 자신에게 온 패킷이 아닌데도 받아들여 처리하는 모드

	4. 이 모드로 해두면 패킷 목적지에 관계없이 처리할 수 있게 됨

	5. 네트워크 감시 목적 등으로 사용됨(악의적으로는 도청 수단)

	



ethtool

사용법 : ethtool [옵션] [이더넷 채널] [파라미터]



옵션

-s : 옵션은 속도, Duplex 등의 값을 변경

-i : 드라이버에 대한 정보를 보여줌

-S : 인터페이스 통계 정보를 보여준다. rx,tx 의 패킷 전송 개수, 바이트 정보, 브로드캐스팅 정보들이다. 대문자 S 를 사용했다는 점을 주의하자.

-a : Auto Negotiation 정보를 자세히 출력

-p : 포트 확인(LED를 깜빡거림)

-k : 네트워크 디바이스의 Offload 정보를 보여준다. 이 Offload 는 이더넷 카드에서 TOE 기능을 지원하게 되면 사용될 수 있는 기능

참고) lshw -C network : 네트워크 관련 정보 확인





grub

부트로더 이해하기



운영체제를 부팅되도록 하는 부트 정보를 담고있는 프로그램



윈도 리눅스 멀티부팅시 윈도우선설치 (윈도가 부트관리자를 지워 멀티부팅이어려움)



종류로는 GRUB LILO 가있으나 GRUB를 주로사용함



GRUB 1버전 설정



부트로더설정



 설정파일위치 : /boot/grub 디렉토리에  menu.lst 파일로 존재 grub.conf 파일명으로 심볼릿 링크 하여 사용



1. timeout : 컴퓨터를시작하여 부트선택화면에서 주어진 시간



2. default 0 : 기본부팅 엔트리 0번부터



3. fallback 1: 기본부팅이 정상부팅되지 못할 때 차선택으로 부팅 엔트리



4. splashimage : xpm형태의 그림 이미지를 압축한 xpm.gz 파일을 grub 메뉴 화면의 배경 이미지로 사용 할 수 있다.



                        지정법 (splashimage=(hd0,0) /boot/grub/splash.xpm.gz) hd(0,0)dms /dev/sda1 파티션을 의미



                        요즈음은 대신 gfxmenu 옵션을 사용함 (gfxmenu (hd0,0) /boot/gfxmenu)



5. hiddenmenu : GRUB를 보이지 않게 하는 옵션



6. 리눅스 부트 엔트리 설정 : 설치되어있는 os의 위치 커널 이미지 그리고 initrd 등이 다음과 같은 형태로 설정



title <부트 엔트리 설명>



  root (하드디스크디바이스명, 부트파티션명)



  kernel 커널이미지경로/커널명 root=루트디바이스명 부트파라미터



  initrd initrd이미지경로/initrd명



 



- title : 부트 엔트리명이나 부트 엔트리에 대한 설정을 임의적 설정 이 때 각 단어 사이즈는 스페이스 바를 이용 공백을 넣을 수 있음



- root : 그 다음ㅁ줄 하드디스크의 디바이스명과 /boot/grub를 포함하는 부트 파티션이 있는 디바이스명을 root 옵션으로 (hd0,0)와 같은 식으로 지정



root (hd0,0)



root 는 grub의 루트 디바이스를 설정하는 옵션으로 /boot 디렉토리를 포함하는 파티션을 말합니다. 즉 root(hd0,0)는 프라이머리 하드디스크의 첫 번째 파티션(/dev/sda1)이 GRUB의 루트 파티션이라는 것을 의미합니다. 만일 root (hd0,4) /dev/sda5 파티션을 GRUB의 루트파티션이라는 것을 의미 



-kernel 



kernel /boot/vmliunz root=/dev/sda1 rhgb quiet vha=771



상기 설정과 같이 kernel  명령라인에 커널이미지 경로와 파일명, 그리고 root파티션의 디바이스명 그리고 부트 파라미터를 지정할 수 있습니다. kernerl 명령 다음에는 커널 이미지가 있는 위치와 커널명을 정확히 지정해 주어야 부팅할 때 오류가 발생하지 않음을 주의하기 바랍니다. 이 때 명시해 주는 커널명은 심볼릭링크된 파일명을 지정해 주어도 상관없다. root 파티션의 디바이스명을 지정해 줄때는 다음과 같이 /dev/sda1 와 같은 형태로 지정해 주는 방법과 UUID-LEVLE 값으로 지정해주는 방법이 있습니다.



root=/dev/sda1



root=UUID=bda35c4e-e693-4adl-86c6-9fea83464fe0



root=LEVEL=No1.Linux



 



-initrd



initrd이미지가 있는 경로와 파일명을 정확하게 지정



initrd /boot/initrd.img



주의점 : initrd 옵션으로 initrd 이미지 파일을 정확하게 설정되지 않은 경우에는 다음 부팅 시에는 커널 패닉에 빠져 부팅이 않됨



 



-커널 파라매터(parameter)



커널 설정 라인에서 사용되는 파라리터로는 rhgb,quite ,vga,runlevel, splash 등이 있습니다 



rhgb : RedHatGraphical Boot (페도라만제공)



quiet : 커널 텍스트 메시지를 화면상으로 출력되지 않게함



vga 해상도 명시 해상도로 부팅할 수 있게함 예)1024*768 24비트 = vga=792로 입력



splash : 커널 텍스트 메시지 대신 이미질 대체하여 보여줌 splash=silent 설정한 이미지로 출력, 실행레벨지정 1 시스템응급시 루트쉘,3~5 콘솔 x-window





GRUB 부트 설정 파일 예제

title win7

rootnoverify (hd1,0)

makeactive 

chainloader +1



GRUB 부트 메뉴 다루기



명령어	설명

root	GRUB루트 파티션 지정 (/boot/grub 티렉토리가 있는 파티션)

kernel	커널 이미지 지정

initrd	initrd.img 이미지 지정

boot	시스템부팅

reboot	GRUB재시작

clear	화면 지우기

cat 파일명	특정 텍스트 파일 보기

chainloader +1	부팅 가능한 파티션의 첫번째 섹터를 읽어 들여 부팅

configfile 파일	root 명령어로 지정된 파티션에 있는 grub.conf 파일 읽어 들이기

find 파일	명시된 파일이 있는 파티션 찾기 명시되는 파일은 절대경로로 표시해야함

geomtry 장치명	명시한 하드 디스크의 정보 체크 리눅스가 된 컴퓨터

md5crypt	md5로 암호화된 열쇠글을 만들어 주는 명령

rootnkverify	주로 윈도로 부팅할 때 사용 명시한 장치를 루트디바이스로 지정하나 마운트하지 않음

setup 장치명	명시한 파티션으로 grub설치

quit	종료

help	도움말





tcpdump

1. ngrep '' tcp dst port 80 -t -Wbyline -q > /root/tmp/ndump

-> TCP 80 port 로 들어오는 패킷을 line단위로 정리하여 /root/tmp/ndump 파일에 저장



2. tcpdump -nnnn -s 0 dst host {ip} and not port 22 -w /root/tmp/tdump

->  22 포트를 제외한 host IP로 인입되는 패킷의 사이즈 제한 없이 간략한 정보를 /root/tmp/tdump로 저장





/lib/modules/ : 커널 모듈 저장소,

*만약 / 파티션의 용량이 부족할 경우, /lib/modules/커널버젼을 확인하여 사용하지 않는 커널버전의 소스는 삭제.





PAM & TCP wrapper 설정



PAM

/etc/pam.d/<데몬명> : 리소스를 제한할 데몬에 대한 pam 설정



[root@test pam.d]# cat sshd 

#%PAM-1.0

auth       required     pam_stack.so service=system-auth

auth       required     pam_nologin.so

account    required     pam_access.so accessfile=/etc/security/sshd_access.conf

account    required     pam_stack.so service=system-auth

password   required     pam_stack.so service=system-auth

session    required     pam_stack.so service=system-auth

session    required     pam_loginuid.so





[root@test pam.d]# cat /etc/security/sshd_access.conf

-:root:ALL EXCEPT 111.11.11.111 111.123.123.22 123.21.12.32



Pam에 의한 접속 거부 문구 : Connection closed by 192.168.11.3



TCP Wrapper(/etc/hosts.allow, /etc/hosts.deny)에 의한 접속 거부 문구 : Connection closed by remote host



만약 ssh 접속이 안된다면 위의 deny 문구를 보고 어디가 문제인지 추측이 가능



접속 순서 : Pam < TCPWrapper





smartctl

참조 : https://brunch.co.kr/@lars/3

 while : ; do smartctl -s on -a -d ata /dev/sdb;sleep 1;done

            1초 간격으로 LED 점등 되는 디스크 확인 후 명령어 중지 ctrl + c



1. 옵션

-i -> HDD의 정보를 출력함

-s on -> smart 기능을 enable 시킴

-t long /dev/hda (Executes extended disk self-test) selftest > HDD의 기본적인 테스트를 진행

-X -> 테스트 중단

-a -> 전체적인 HDD의 리포트를 쭉 출력해 줌

-d TYPE -> 디바이스 타입 지정 <ata, scsi, marvell, 3ware,N>

 

2. Raid-Controller 별 옵션

LSI 3ware SATA RAID Controller -> -d 3ware,N /dev/twx

Areca SATA[/SAS] RAID Controller → -d areca,N[/E] /dev/sgx

HighPoint RocketRAID SATA RAID Controller -> -d hpt,L/M/N /dev/sdx

CCISS(HP/Compaq Smart Array Controller -> -d cciss,N /dev/cciss/cXd0

LSI MegaRAID SAS RAID Controller(SATA장착) -> -d sat+megaraid,N /dev/sdX

Dell PERC 5/i, 6/i controller → -d megaraid,N /dev/sdX

Adaptec SAS RAID Controller(devices supported by aacraid driver) -> -d aacraid,H,L,ID /dev/sdx

----> N 은 sas port number를 지정한다.

 

** 부분은 문제가 있다. (0이 되어야한다.)

**1 Raw_Read_Error_Rate - 디스크 표면으로부터 데이터를 읽는 과정에서 문제가 있을때 (주로 물리적인 충격으로 유발됨)

2 Throughput_Performance

3 Spin_Up_Time - 플레터 회전이 제로 rpm에서 최대 rpm에 도달하는게 걸리는 평균 시간

4 Start_Stop_Count - 플레터가 회전하고 정지한 횟수

**5 Reallocated_Sector_Ct - 섹터에 문제가 생겨서 스페어영역의 섹터로 대체한 횟수

**7 Seek_Error_Rate - 탐색 오류율

8 Seek_Time_Performance

9 Power_On_Hours - 하드에 전원이 인가된 시간

**10 Spin_Retry_Count - 최대 rpm에 도달하기위해서 회전을 시도하는 횟수(정상이라면 1번에 끝나야한다)

12 Power_Cycle_Count - 전원 on/off 횟수

192 Power-Off_Retract_Count - 헤드가 플레터(디스크)에서 벗어나는 횟수(간단하게 parking 위치로 이동한 횟수)

193 Load_Cycle_Count -헤드가 플레터위로 진입한 횟수

**194 Temperature_Celsius - 하드디스크 온도(최소 25도, 최대 62도) 100도를 넘으면 빨리 교체를 진행한다.(미디엄에러)

196 Reallocated_Event_Count - 스페어 영역으로 대체된 섹터로 부터 데이터를 읽어간 횟수

**197 Current_Pending_Sector - 불안정적인 섹터로 스페어영역 섹터로 remap을 준비중이거나 읽는 과정에 문제가 생김(medium error)

**198 Offline_Uncorrectable - read/write에 문제가 생긴 섹터, 즉 디스크 표면이 손상됨(bad sector)

**199 UDMA_CRC_Error_Count - 하드디스크 인터페이스를 통해 데이터 전송과정에 발생한 CRC 횟수(CRC : 순환중복검사, UDMA방식을 통해 메모리<->HDD간 전송된 데이터에 오류가 있는지 확인하기 위한 체크값)

241 Total_LBAs_Written

242 Total_LBAs_Read



-디스크 에러 있을 경우

[root@test ~]# smartctl -s on -a -d sat+megaraid,1 /dev/sda

 smartctl 6.0 2012-10-10 r3643 [x86_64-linux-2.6.32-696.3.2.el6.x86_64] (local build)

 Copyright (C) 2002-12, Bruce Allen, Christian Franke, www.smartmontools.org

 

 === START OF INFORMATION SECTION === -> 디스크 정보

 Device Model:     TOSHIBA MG04ACA200N

 Serial Number:    579FK2NVFVMC

 LU WWN Device Id: 5 000039 7cbe00a10

 Firmware Version: FJ2D

 User Capacity:    2,000,398,934,016 bytes [2.00 TB]

 Sector Size:      512 bytes logical/physical

 Rotation Rate:    7200 rpm

 Device is:        Not in smartctl database [for details use: -P showall]

 ATA Version is:   ATA8-ACS (minor revision not indicated)

 SATA Version is:  SATA 3.0, 6.0 Gb/s (current: 6.0 Gb/s)

 Local Time is:    Tue Feb  6 05:43:15 2018 KST

 SMART support is: Available - device has SMART capability.

 SMART support is: Enabled

 

 === START OF ENABLE/DISABLE COMMANDS SECTION ===

 SMART Enabled.

 

 === START OF READ SMART DATA SECTION ===

 SMART overall-health self-assessment test result: PASSED

 Warning: This result is based on an Attribute check.

 

 General SMART Values:

 Offline data collection status:  (0x82) Offline data collection activity

                                         was completed without error.

                                         Auto Offline Data Collection: Enabled.

 Self-test execution status:      (   0) The previous self-test routine completed

                                         without error or no self-test has ever

                                         been run.

 Total time to complete Offline

 data collection:                (   90) seconds.

 Offline data collection

 capabilities:                    (0x5b) SMART execute Offline immediate.

                                         Auto Offline data collection on/off support.

                                         Suspend Offline collection upon new

                                         command.

                                         Offline surface scan supported.

                                         Self-test supported.

                                         No Conveyance Self-test supported.

                                         Selective Self-test supported.

 SMART capabilities:            (0x0003) Saves SMART data before entering

                                         power-saving mode.

                                         Supports SMART auto save timer.

 Error logging capability:        (0x01) Error logging supported.

                                         General Purpose Logging supported.

 Short self-test routine

 recommended polling time:        (   2) minutes.

 Extended self-test routine

 recommended polling time:        ( 228) minutes.

 SCT capabilities:              (0x003d) SCT Status supported.

                                         SCT Error Recovery Control supported.

                                         SCT Feature Control supported.

                                         SCT Data Table supported.

 

 SMART Attributes Data Structure revision number: 16

 Vendor Specific SMART Attributes with Thresholds:

 ID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE

   1 Raw_Read_Error_Rate     0x000b   100   100   050    Pre-fail  Always       -       0

   2 Throughput_Performance  0x0004   100   100   000    Old_age   Offline      -       0

   3 Spin_Up_Time            0x0027   100   100   001    Pre-fail  Always       -       3277

   4 Start_Stop_Count        0x0032   100   100   000    Old_age   Always       -       3

   5 Reallocated_Sector_Ct   0x0033   100   100   050    Pre-fail  Always       -       0

   7 Seek_Error_Rate         0x000a   100   100   000    Old_age   Always       -       0

   8 Seek_Time_Performance   0x0004   100   100   000    Old_age   Offline      -       0

   9 Power_On_Hours          0x0032   090   090   000    Old_age   Always       -       4034

 10 Spin_Retry_Count        0x0032   100   100   000    Old_age   Always       -       0

 12 Power_Cycle_Count       0x0032   100   100   000    Old_age   Always       -       3

 192 Power-Off_Retract_Count 0x0032   100   100   000    Old_age   Always       -       0

 193 Load_Cycle_Count        0x0032   100   100   000    Old_age   Always       -       4

 194 Temperature_Celsius     0x0022   100   100   000    Old_age   Always       -       29 (Min/Max 24/37)

 196 Reallocated_Event_Count 0x0032   100   100   000    Old_age   Always       -       0

 198 Offline_Uncorrectable   0x0030   100   100   000    Old_age   Offline      -       0

 199 UDMA_CRC_Error_Count    0x0032   200   253   000    Old_age   Always       -       0

 241 Total_LBAs_Written      0x0032   100   100   000    Old_age   Always       -       17985103766

 242 Total_LBAs_Read         0x0032   100   100   000    Old_age   Always       -       22333580598

 

 SMART Error Log Version: 1 ------------------->> !! SMART Error 발생 시 HDD 교체 진행

 ATA Error Count: 3

         CR = Command Register [HEX]

         FR = Features Register [HEX]

         SC = Sector Count Register [HEX]

         SN = Sector Number Register [HEX]

         CL = Cylinder Low Register [HEX]

         CH = Cylinder High Register [HEX]

         DH = Device/Head Register [HEX]

         DC = Device Command Register [HEX]

         ER = Error register [HEX]

         ST = Status register [HEX]

 Powered_Up_Time is measured from power on, and printed as

 DDd+hh:mm:SS.sss where DD=days, hh=hours, mm=minutes,

 SS=sec, and sss=millisec. It "wraps" after 49.710 days.

 

 Error 3 occurred at disk power-on lifetime: 4034 hours (168 days + 2 hours)

   When the command that caused the error occurred, the device was active or idle.

 

   After command completion occurred, registers were:

   ER ST SC SN CL CH DH

   -- -- -- -- -- -- --

  40 41 48 a3 6a 47 40  Error: UNC at LBA = 0x00476aa3 = 4680355

 

   Commands leading to the command that caused the error were:

   CR FR SC SN CL CH DH DC   Powered_Up_Time  Command/Feature_Name

   -- -- -- -- -- -- -- --  ----------------  --------------------

  60 40 80 60 7f 48 40 00   4d+21:41:15.918  READ FPDMA QUEUED

   60 10 78 30 7f 48 40 00   4d+21:41:15.918  READ FPDMA QUEUED

   60 10 70 00 7f 48 40 00   4d+21:41:15.918  READ FPDMA QUEUED

   60 10 68 70 7e 48 40 00   4d+21:41:15.918  READ FPDMA QUEUED

   60 10 60 20 7e 48 40 00   4d+21:41:15.918  READ FPDMA QUEUED

 

 Error 2 occurred at disk power-on lifetime: 4034 hours (168 days + 2 hours)

   When the command that caused the error occurred, the device was active or idle.

 

   After command completion occurred, registers were:

   ER ST SC SN CL CH DH

   -- -- -- -- -- -- --

  40 41 68 a3 6a 47 40  Error: UNC at LBA = 0x00476aa3 = 4680355

 

   Commands leading to the command that caused the error were:

   CR FR SC SN CL CH DH DC   Powered_Up_Time  Command/Feature_Name

   -- -- -- -- -- -- -- --  ----------------  --------------------

  60 10 58 80 86 46 40 00   4d+21:41:10.500  READ FPDMA QUEUED

   60 10 38 40 86 46 40 00   4d+21:41:10.500  READ FPDMA QUEUED

   60 10 30 00 86 46 40 00   4d+21:41:10.500  READ FPDMA QUEUED

   60 10 20 20 85 46 40 00   4d+21:41:10.500  READ FPDMA QUEUED

   60 08 18 08 ac 27 40 00   4d+21:41:10.493  READ FPDMA QUEUED

 

 Error 1 occurred at disk power-on lifetime: 4010 hours (167 days + 2 hours)

   When the command that caused the error occurred, the device was active or idle.

 

   After command completion occurred, registers were:

   ER ST SC SN CL CH DH

   -- -- -- -- -- -- --

  40 41 28 a3 6a 47 40  Error: WP at LBA = 0x00476aa3 = 4680355

 

   Commands leading to the command that caused the error were:

   CR FR SC SN CL CH DH DC   Powered_Up_Time  Command/Feature_Name

   -- -- -- -- -- -- -- --  ----------------  --------------------

  61 08 a8 10 85 26 40 00   3d+21:39:01.826  WRITE FPDMA QUEUED

   61 08 a0 d8 84 26 40 00   3d+21:39:01.826  WRITE FPDMA QUEUED

   61 08 98 38 84 26 40 00   3d+21:39:01.826  WRITE FPDMA QUEUED

   61 08 90 60 79 26 40 00   3d+21:39:01.826  WRITE FPDMA QUEUED

   61 10 88 50 76 26 40 00   3d+21:39:01.826  WRITE FPDMA QUEUED

 

 SMART Self-test log structure revision number 1

 No self-tests have been logged.  [To run self-tests, use: smartctl -t]

 

 

 SMART Selective self-test log data structure revision number 1

 SPAN  MIN_LBA  MAX_LBA  CURRENT_TEST_STATUS

     1        0        0  Not_testing

     2        0        0  Not_testing

     3        0        0  Not_testing

     4        0        0  Not_testing

     5        0        0  Not_testing

 Selective self-test flags (0x0):

   After scanning selected spans, do NOT read-scan remainder of disk.

 If Selective self-test is pending on power-up, resume after 0 minute delay.









lshw : H/W 리스트 출력



옵션

-short : 간략히 출력

-C <H/W 분류> : 특정 H/W class만 출력



EX)

[root@test ~]# lshw -short

H/W path           Device     Class      Description

====================================================

                              system     X8SIL

/0                            bus        X8SIL

/0/0                          memory     64KiB BIOS

/0/4                          processor  Intel(R) Xeon(R) CPU           X3440  @ 2.53GHz

/0/4/5                        memory     256KiB L1 cache

/0/4/6                        memory     1MiB L2 cache

/0/4/7                        memory     8MiB L3 cache

/0/2a                         memory     4GiB System Memory

/0/2a/0                       memory     DIMM [empty]

/0/2a/1                       memory     DIMM [empty]

/0/2a/2                       memory     4GiB DIMM Synchronous 1333 MHz (0.8 ns)

/0/2a/3                       memory     DIMM [empty]

/0/755                        generic

/0/775                        generic

/0/100                        bridge     Core Processor DMI

/0/100/3                      bridge     Core Processor PCI Express Root Port 1

/0/100/5                      bridge     Core Processor PCI Express Root Port 3

/0/100/8                      generic    Core Processor System Management Registers

/0/100/8.1                    generic    Core Processor Semaphore and Scratchpad Registers

/0/100/8.2                    generic    Core Processor System Control and Status Registers

/0/100/8.3                    generic    Core Processor Miscellaneous Registers

/0/100/10                     generic    Core Processor QPI Link

/0/100/10.1                   generic    Core Processor QPI Routing and Protocol Registers

/0/100/1c                     bridge     5 Series/3400 Series Chipset PCI Express Root Port 1

/0/100/1c.4                   bridge     5 Series/3400 Series Chipset PCI Express Root Port 5

/0/100/1c.4/0      eth0       network    82574L Gigabit Network Connection

/0/100/1c.5                   bridge     5 Series/3400 Series Chipset PCI Express Root Port 6

/0/100/1c.5/0      eth1       network    82574L Gigabit Network Connection

/0/100/1d                     bus        5 Series/3400 Series Chipset USB2 Enhanced Host Controller

/0/100/1e                     bridge     82801 PCI Bridge

/0/100/1e/3                   display    MGA G200eW WPCM450

/0/100/1f                     bridge     3400 Series Chipset LPC Interface Controller

/0/100/1f.2        scsi0      storage    5 Series/3400 Series Chipset 4 port SATA AHCI Controller

/0/100/1f.2/0      /dev/sda   disk       160GB ST3160815AS

/0/100/1f.2/0/1    /dev/sda1  volume     196MiB EXT3 volume

/0/100/1f.2/0/2    /dev/sda2  volume     4777MiB EXT3 volume

/0/100/1f.2/0/3    /dev/sda3  volume     1913MiB Linux swap volume

/0/100/1f.2/0/4    /dev/sda4  volume     142GiB Extended partition

/0/100/1f.2/0/4/5  /dev/sda5  volume     2870MiB Linux filesystem partition

/0/100/1f.2/0/4/6  /dev/sda6  volume     9546MiB Linux filesystem partition

/0/100/1f.2/0/4/7  /dev/sda7  volume     130GiB Linux filesystem partition

/0/100/1f.2/1      /dev/sdb   disk       250GB ST3250318AS

/0/100/1f.2/1/1    /dev/sdb1  volume     192MiB EXT3 volume

/0/100/1f.2/1/2    /dev/sdb2  volume     18GiB EXT3 volume

/0/100/1f.2/1/3    /dev/sdb3  volume     1908MiB Linux swap volume

/0/100/1f.2/1/4    /dev/sdb4  volume     212GiB Extended partition

/0/100/1f.2/1/4/5  /dev/sdb5  volume     13GiB Linux filesystem partition

/0/100/1f.2/1/4/6  /dev/sdb6  volume     18GiB Linux filesystem partition

/0/100/1f.2/1/4/7  /dev/sdb7  volume     179GiB Linux filesystem partition

/0/100/1f.3                   bus        5 Series/3400 Series Chipset SMBus Controller

/1                            power      To Be Filled By O.E.M.



[root@test ~]# lshw -C memory

  *-firmware

       description: BIOS

       vendor: American Megatrends Inc.

       physical id: 0

       version: 1.1 (05/27/2010)

       size: 64KiB

       capacity: 4032KiB

       capabilities: isa pci pnp upgrade shadowing escd cdboot bootselect socketedrom edd int13floppy1200 int13floppy720 int13floppy2880 int5printscreen int9keyboard int14serial int17printer int10video acpi usb ls120boot zipboot biosbootspecification

  *-cache:0

       description: L1 cache

       physical id: 5

       slot: L1-Cache

       size: 256KiB

       capacity: 256KiB

       capabilities: internal write-through instruction

  *-cache:1

       description: L2 cache

       physical id: 6

       slot: L2-Cache

       size: 1MiB

       capacity: 1MiB

       capabilities: internal write-through unified

  *-cache:2

       description: L3 cache

       physical id: 7

       slot: L3-Cache

       size: 8MiB

       capacity: 8MiB

       capabilities: internal write-back unified

  *-memory

       description: System Memory

       physical id: 2a

       slot: System board or motherboard

       size: 8GiB

     *-bank:0

          description: DIMM Synchronous 1067 MHz (0.9 ns)

          product: HMT31GR7BFR8C-G7

          vendor: Hyundai

          physical id: 0

          serial: 0C027037

          slot: DIMM1A

          size: 8GiB

          width: 64 bits

          clock: 1067MHz (0.9ns)

     *-bank:1

          description: DIMM [empty]

          product: ModulePartNumber01

          vendor: Manufacturer01

          physical id: 1

          serial: SerNum01

          slot: DIMM1B

     *-bank:2

          description: DIMM [empty]

          product: ModulePartNumber02

          vendor: Manufacturer02

          physical id: 2

          serial: SerNum02

          slot: DIMM2A

     *-bank:3

          description: DIMM [empty]

          product: ModulePartNumber03

          vendor: Manufacturer03

          physical id: 3

          serial: SerNum03

          slot: DIMM2B





rpm

https://www.lesstif.com/pages/viewpage.action?pageId=7635004



옵션

-q	--query		패키지 정보 질의

-i	--install	패키지 설치

-U	--upgrade	패키지 업그레이드

-e	--erase		패키지 삭제

-V	--verify	패키지 검증

-K	--checksig	서명 검증

-h			설치 진행상황을 #문자를 이용하여 출력

**--nodeps		의존성 확인 X

--replacefiles		기존에 설치된 패키지 파일을 교체

--oldpackage		패키지 버전 다운그레이드

**--force			위 3개 옵션 합친것

--chanelog		패키지 개정 이력 확인



설치

rpm -ivh XXX.rpm



업그레이드

rpm -Uvh XXX.rpm



전체 패키지 확인

rpm -qa | more



패키지의 자세한정보 출력

# rpm -qi httpd



설치전 패키지 자세한정보 출력

rpm -qpi httpd-2.2.15-29.el6.centos.x86_64.rpm 



패키지 개정이력 확인

# rpm -q --changelog openssl



프로그램이나 파일이 어떤 패키지로부터 설치되었는지 확인

# rpm -qf `which httpd`

++ -qf 옵션으로 변조를 검사한다.



패키지내 어떤 파일이 어디에 설치되었는지 확인

# rpm -ql httpd



패키지가 설치될 전체 경로 확인

# rpm -qpl httpd-2.2.15-29.el6.centos.x86_64.rpm  



패키지 설치시 필요한 의존성 목록 확인

# rpm -qR mod_ssl



설치전 의존성 확인

# rpm -qRp mod_ssl-2.2.15-29.el6.centos.x86_64.rpm







yum

https://www.lesstif.com/pages/viewpage.action?pageId=6979667



옵션

-y : 질문을 모두 yes 처리



패키지 설치

yum install



패키지 업데이트

yum update



업데이트 될 패키지 목록

yum check-update



현재 등록된 repossitory list 출력

yum repolist = /etc/yum.repos.d/



rpm 설치

yum localinstall XX.rpm

-> transaction 기록이 남아 yum history로 rollback 가능



모든 트랜잭션 보기

yum history list all



트랜잭션 정보 보기

yum history info X



트랜잭션 롤백

yum history undo X



패키지 정보 확인

yum info <패키지명>



의존성 파일도 함께 삭제

yum autoremove







touch



옵션

-c newfile : 현재시간으로 날짜정보 변경

-t YYYYMMDDhhmm newfile : 날짜정보 변경

-r oldfile newfile : newfile을 oldfile의 날짜정보와 같게 변경







date



date -d '1 day ago' -> 어제

date -d '1 week' -> 1주일 후

date -d 'this friday'	# 이번주 금요일

date -d 'last monday'	# 지난 월요일

date -d 'next tuesday'	# 다음 화요일



# 2018년 1월 3일 7시 32분 10초를 기준으로 2일 5시간 17분후

date -d '2018-01-03 07:32:10 + 2 day 5 hours 17 minute'	



# 현재 시간으로부터 2일전의 년-월-일 시:분:초 형식으로 표시

date '+%Y-%m-%d %H:%M:%S' -d '2 day ago'



쉘스크립트에서 해당 시간을 변수에 담기

yesterday=$(date -d '1 day ago')



파일명에 날짜 포함시키기

touch test_$(date '+%Y.%m.%d_%H:%M')

 

출력형식은 FORMAT값을 변경함으로써 이루어진다. 다음과 같은 포맷인자를 이용할 수 있다.

%%	% 자체를 표시한다.
%a	요일이름을 표시한다. (일..토)
%A	완전한요일이름을 표시한다. (일요일..토요일)
%b	월이름을 표시한다. (1월..12월)
%B	완전한월 이름을 표시한다. (1월..12월)
%c	날짜와 시간을 표시한다. (2007년 11월 14일 (수) 오전 12시 50분 16초)
%C	세기를 나타낸다. (년을 100으로 나눈 몫)
%d	월일 (01..31)
%D	월일 (mm/dd/yy)
%e	월일 (1..31)
%F	%Y-%m-%d 와 같다.
%g	년도로 마지막 두자리만 표시
%G	년도로 모든자리 표시
%h	%b 와 같다.
%H	시간 (00..23)
%I	시간 (01..12)
%j	년일(001..366)
%k	시간 (0..23)
%l	시간 (1..12)
%m	월 (01..12)
%M	분 (00..59)
%n	개행문자
%N	나노초 (000000000..999999999)
%P	오전 오후
%p	오전 오후
%r	시간 (오전/오후 hh시 mm분 ss초)
%R	시간 (hh시 mm분)
%s	UTC 기준 1970-01-01 부터 지금까지 흐른 초
%t	탭문자
%T	24시간 (hh:mm:ss)
%u	주중 요일 (1..7), 1이 월요일이다
%U	1년중 몇번째 주인지, 일요일 기준 (00..53)
%V	1년중 몇번째 주인지, 월요일 기준 (00..53)
%w	주중 요일 (0..6), 0은 일요일
%x	mm/dd/yy
%X	%H:%M:%S 와 동일
%Y	년도 (1970..)
%Z	타임존 대한민국은 KST

tune2fs : 파일시스템 튜닝 (양날의 칼, 잘쓰면 성능향상, 못쓰면 파일시스템 손상)

!! 고로 -l 옵션만을 사용한다.

http://develop.sunshiny.co.kr/952

http://pchero21.com/?p=1267



옵션

-l : 자세히 출력

-m 20 /dev/sda1 : /dev/sda1 장치의 예약블록을 20%로 변경



[root@localhost ~]# tune2fs -l /dev/sda1 | grep state

Filesystem state:         clean

-> clean and error이면 /var/log/message, smartctl 도 확인하여 disk 교체



[root@master ~]# df -h

Filesystem            Size  Used Avail Use% Mounted on

/dev/hda8             154G   16G  131G  11% /



/dev/hda8 파티션의 블록 조회

[root@master ~]# tune2fs -l /dev/hda8 | grep -i "block count"

Block count:              41662561

Reserved block count:     2083128



계산 : 2083128 / 41662561 = 0.049 (5%)

   /dev/hda8 파티션의 약 5%의 공간을 예비 블록으로 확보



전체 디스크 계산

   154,000 * 0.05 = 7,700 (7.7)

   /dev/hda8 파티션에서 약 7.7GB 공간을 예비 블록으로 확보







dd : 블록 단위로 파일을 복사하거나 파일을 변환할 수 있음

https://ko.wikipedia.org/wiki/Dd_(%EC%9C%A0%EB%8B%89%EC%8A%A4)



dd if=/dev/ad0 of=/dev/ad1 bs=1M conv=noerror

하드 디스크 드라이브 "ad0"을 "ad1"으로 복제한다.



dd를 이용하여 디스크를 0으로 채워 소거하는 방법은 아래와 같다:

dd if=/dev/zero of=/dev/sda bs=4k





라이브 벤치마크를 테스트하고, 1024바이트 블록에 대한 순차 시스템 읽기/쓰기 성능을 분석하려면 다음과 같이 진행한다:

dd if=/dev/zero bs=1024 count=1000000 of=file_1GB

dd if=file_1GB of=/dev/null bs=1024







swap



mkswap : swap 파티션이나 swap 파일을 생성하는 명령어 



사용법

mkswap [option] swapfile or swappartition [size] 



옵션 

-c : swap 파티션 생성시 사용 



예문 

10240K 사이즈의 /swap_file 생성 

mkswap /swap_file 10240 

  



dd 명령으로 swap 파일로 사용할 파일을 용량이 넉넉한 파티션에 생성 후 

mkswap 명령으로 해당 파일을 swap 파티션으로 만들어준다. 

--------->>>>

* 스왑 2G 추가

[root@~]# touch /home/2G_swap

[root@~]# dd if=/dev/zero of=/home/2G_swap bs=1024 count=2048000

[root@~]# mkswap /home/2G_swap

[root@~]# swapon /home/2G_swap

[root@~]# free -m

             total       used       free     shared    buffers     cached

Mem:          3955       3850        105          0         16       1498

-/+ buffers/cache:       2335       1620

Swap:         3955       1284       2671



swapon : swap 파티션이나 swap 파일을 구동하는 명령어 



사용법

swapon [option] swapfile or swappartition 



옵션 

-a : /etc/fstab 에 있는 swap 을 모두 활성화 

-s : swap 파티션의 상태를 보여줌 



예문 

/etc/fstab 에 있는 swap 을 모두 활성화 

swapon -a 



swapoff : swap 파티션이나 swap 파일의 구동을 중단시키는 명령어 



사용법

swapoff swapfile or swappartition 



예문 

swapoff /swap_file 







/etc/fstab

https://www.lesstif.com/pages/viewpage.action?pageId=20776621



#cat /etc/fstab 

/dev/sda3                    /                     ext3       defaults              1 1

/dev/sda1                    /boot                 ext3       defaults              1 2

tmpfs                        /dev/shm              tmpfs      defaults              0 0

devpts                       /dev/pts              devpts     gid=5,mode=620        0 0

sysfs                        /sys                  sysfs      defaults              0 0

proc                         /proc                 proc       defaults              0 0

/dev/sda2                    swap                  swap       defaults              0 0

[파일시스템 장치명]	[마운트포인트]	[파일시스템종류]	[옵션]	   [dump관련] [파일점검옵션]



[옵션] : 네번째 항목으로 파일시스템 속성을 설정하는 옵션

default : rw, nouser, auto, exec, suid 속성을 모두 가지는 속성, 가장 일반적인 파일시스템에서 사용

auto : 부팅시 자동마운트

exec : 실행파일이 실행되는 것을 허용하는 파일시스템

suid : SetUID와 SetGID의 사용을 허용하는 파일시스템 

ro : 읽기전용 파일시스템(Read Only)

rw : 읽고쓰기 파일시스템(Read, Write)

user : 일반 계정사용자들도 마운트를 할 수 있는 파일시스템

nouser : 일반 계정사용자들은 마운트 할 수 없는 파일시스템. (root만 mount)

noauto : 부팅시 자동마운트되지 않게 함.

noexec : 실행파일을 실행되지 못하게 하는 파일시스템

nosuid : SetUID와 SetGID의 사용을 허용하지 않는 파일시스템

usrquota : 개별 사용자의 쿼타(Quota)설정이 가능한 파일시스템 ---> 사용자 디스크 사용량 제한(/home/)

grpqquota : 그룹별 쿼타(Quota)설정이 가능한 파일시스템

noatime : file access time을 기록하지 않는다. 주로 파일읽기가 잦은 웹서버에서 부하를 낮추기 위해 이 옵션을 설정한다.

nodiratime : directory access time을 기록하지 않는다. 주로 웹서버에서 부하를 낮추기 위해 이 옵션을 설정한다.

barrier=0 : barrier는 읽기/쓰기 보장옵션으로, 0 : disabled 하여 검토를 안함으로 속도향상을 위해 사용(db서버군은 모든 파티션에, 일반 서버군은 db가 설치된 파티션에 설정)



[dump관련설정] : 0 또는 1을 가질수있는 설정, 1은 데이터백업등을 위해 dump가 가능한 파일시스템이며,

                                                                 0은 dump 명령으로 덤프되지 않는 파일시스템 



[파일점검옵션] : 0 또는 1, 그리고 2가 올수있는 설정, 0은 부팅시 실행되는 fsck가 실행되지 않는 설정

                                                                          1은 루트파일시스템을 의미

                                                                          2는 루트파일시스템 이외의 파일시스템을 의미

                        즉, 여기서 설정된 파일시스템의 순서를 기준으로 부팅시 실행되는 fsck의 순서가 결정

**Quota : 사용량 제한





▣ 커널관리 파일



- insmod

: 모듈 추가. 커널 디렉토리를 찾아서 해당 모듈을 추가한다.

■ 형식 : insmod [옵션] [오브젝트파일]

■ 옵션

  -k : autoclean 을 사용하여 적재



- rmmod

: 모듈 삭제

■ 형식 : rmmod [옵션] [모듈]

■ 옵션

  -r : 의존관계에 있는 모듈을 한번에 삭제



- lsmod

: 추가된 모듈 출력(/proc/modules 를 참조한다)

■ 형식 : lsmod [옵션]

■ 옵션

  -V : lsmod 버전 출력



- modprobe

: 모듈 추가. depmod에 의해 갱신된 modules.dep에서 찾아 추가한다. insmod와 달리 해당 커널 디렉토리로 갈 필요없이 아무위치에서나 모듈을 추가할수 있다. 또한 의존성이 필요한 모듈이나 먼저 실행되어야 할 모듈이 있다면 그 모듈부터 추가하고 해당 모듈을 추가한다

■ 형식 : modprobe [옵션] [오브젝트파일]

■ 옵션

  -k : autoclean 을 사용하여 추가

  -r : 모듈 삭제



- depmod

: 의존성 검사를 한뒤 modules.dep 파일을 갱신한다. kerneld나 modprobe를 실행하기 전엔 꼭 depmod -a를 사용하는 습관을 들인다

■ 형식 : depmod [옵션]

■ 옵션



- modinfo

: 모듈 정보 확인

■ 형식 : modinfo [모듈명]



※ autoclean

autoclean라는 플레그를 사용하면 커널 데몬(kerneld)에 의해 일정시간 사용하지 않는 모듈을 삭제한다. 단 커널 컴파일시 kerneld 지원 여부를 물을때 Y를 해야 사용 가능



※ 참고사항

insmod는 '/lib/modules/커널버전' 디렉토리를 뒤져 해당 모듈이 있으면 메모리에 올려준다.

modprobe는 depmod에 의해 생성된 modules.dep에서 모듈을 찾아 올린다. 그리고 해당 모듈에

의존성이 있거나 해당모듈보다 선행되어야 하는 모듈이 있으면 그 모듈도 같이 올려준다.

이 부분이 insmod와 가장 큰 차이점이다.



예를 들어 vfat란 모듈을 올리기 위해서는 fat란 모듈을 먼저 올려야 하는데, fat 모듈이 메모리에 올라가 있지 않은 상태에서

# insmod vfat 하면 fat에 대한 symbol을 찾지못해 vfat 모듈을 올리지 못하지만

# modprobe vfat 을 실행하면 자동으로 먼저 fat 모듈을 올리고, 그 다음으로 vfat 모듈을 올린다

(커널 컴파일시 fat, vfat을 모듈로 설정했다고 가정)

modprobe로 해당 모듈을 찾지 못하는 경우 modules.dep에 없을 가능성이 크므로

#depmod -a 해서 모듈 의존 관계를 새롭게 갱신시킬 필요가 있다.



참고로 의존 관계에 있는 모듈들을 한꺼번에 내리려면 rmmod -r 옵션을 하면 된다.







fuser(umount 안될 때 주로 사용)

fuser 명령어는 특정파일을 어떤프로세스에서 사용하고 있는지 확인이 필요할 때,

또는 특정 파일이 사용되고 있는 프로세스 ID를 확인하고자 할때 사용되는 명령어로

특정 파일과 PID를 KILL 또는 재시작 할 수도 있습니다.



[root@test ~]# fuser -u /disk

[root@test ~]# fuser -a /disk

[root@test ~]# fuser -m /disk

[root@test ~]# fuser -k 80/tcp



옵션

-a : 사용되고 있지 않은 파일까지도 표시한다.

-k : 지정된 파일과 관련된 모든 프로세스들을 KILL 한다.

-i : 프로세스를 KILL 하기전에 사용자에게 확인한다.

-n space : 지정된 공간(file, udp, or , tcp)내에서 검색한다.

-s : 결과를 간략히 출력한다.

-u : 프로세스 ID(PID)의 소유자를 보여준다.

-m : 지정한 파일이나 디렉토리가 마운트된 파일시스템에서 실행되고 있는 프로세스의 PID 출력

-v : 자세한 출력모드 (프로세스의 User, PID, ACCESS, COMMAND를 보여줌)



예시)

[root@test ~]# fuser -mv /disk/

                     USER        PID ACCESS COMMAND

/disk/               root     kernel mount  /disk/home



[root@test ~]# fuser -k /disk/







tail

-f : 파일 감시

-F : -f 옵션 업그레이드 버젼, 감시중인 파일명이 바뀌어도 멈추지 않는다.

-n수 : 끝에서 지정된 수만큼 줄을 표시

-n +20 : 20번째 줄 이후를 출력

-v : 입력파일이름 표시

-q : 입력파일이름 표시 X



[root@localhost log]# tail -v messages

==> messages <==



[root@localhost log]# tail -q messages

Feb 21 23:32:22 localhost freshclam[4391]: OK







head

-n 20 : 20행까지 출력

-c 200 : 200byte까지의 내용을 출력

-q : 파일이름 표시 X

-v : 파일이름 표시







/etc/sysconfig/network



NETWORKING=yes

NETWORKING_IPV6=no

HOSTNAME=localhost

GATEWAY=192.168.0.1

→ IPV4는 사용, IPV6는 사용 안함

→ 호스트명은 localhost

→ 기본 게이트웨이는 192.168.0.1



해당파일에서 hostname 변경시 리붓이후 적용된다.

hostname <호스트명> 으로 호스트명 변경 후 해당 파일에도 호스트명을 변경해주는 것이 좋다.



/etc/sysconfig/network-scripts/ifcfg-ethX

-> ethX 설정





xargs : 표준입력으로부터의 명령라인을 실행



옵션

-t : xargs를 통해 구성된 명령어를 표준 에러로 출력

-i : xargs에 전달된 라인 전체를 뒤에 나오는 명령어의 인자로 사용(공백 포함 출력도 하나의 인자로 해석)

디폴트로 라인 전체를 의미하는 기호는 {}



find를 이용하여 mtime이 30일 이상된 파일들을 ..bak으로 바꾸기

$ find . -mtime +30 | xargs mv -i {} {}.bak  



find를 이용하여 *.mp3 파일을 지우기

$ find . -name '*.mp3' | xargs rm 



ls 를 이용해서 text 파일 목록을 가져온 뒤 각각의 파일내용을  cat으로 읽고 병합파일 만듬

$ ls *.txt | xargs cat >> abc.merge 



하위 폴더 내에서 모든 C로 끝나는 파일들을 찾아, 파일이름과, 파일의 날짜를 c_files.txt파일에 저장

find . -name "*.c" | xargs -I {} sh -c 'echo -n {} >> c_files.txt; stat -c %Y {} >> c_files.txt'







netstat



옵션

-a : 현재다른PC와 연결(Established)되어 있거나 대기(Listening)중인 모든 포트 번호를 확인

-r : 라우팅 테이블 확인 및 커넥션되어 있는 포트번호를 확인

-n : 현재 다른PC와 연결되어 있는 포트번호를 확인(IP주소로 화면 출력)한다

-e : 랜카드에서 송수한 패킷의 용량 및 종류를 확인

-s : IP, ICMP, UDP프로토콜별의 상태를 보여줌

-t : tcp protocol

-u : udp protocol

-p : 해당프로토콜을 사용하는 프로그램, 프로세스 ID 보여줌

-c : 1초 단위로 보여줌

-l : 대기중인 소켓 리스트만 보여준다. 동일 옵션은 --listening

-p : PID(프로세서 ID) 와 사용중인 프로그램명이 표시된다. 동일 옵션은 --program

-o : 연결 대기 시간 표기. 동일 옵션은 --timers







pstree

리눅스 명령어 pstree는 프로세스의 상관관계(부모-자식 관계)를 트리 형태로 출력해주는 명령어로써, 관계를 트리 형태로 출력해주므로 계층 관계를 한 눈에 파악할 수 있다.



옵션

-p : pid도 출력

-u : uid도 출력

-H PID : 지정한 PID의 프로세스와 부모 프로세스를 하이라이트 형태로 출력

-h : 현재 프로세스와 부모 프로세스를 하이라이트 형태로 출력

-n : pid를 기준으로 정렬하여 출력







strace : 특정 프로그램의 시작부터 종료까지의 실행 시퀀스를 디버깅하여 시스템 콜과 시그널을 감시



옵션

ls 바이너리(명령어) 추적

$ strace ls



특정 시스템 콜 추적( -e )

$ strace -e open ls



여러 개의 시스템 콜 출력( -e trace= )

$ strace -e trace=open,read ls /home



결과를 파일에 저장( -o )

$ strace -o output.txt ls



실행중인 프로세스 시스템 콜 출력( -p )

$ strace -p <PID>



시간정보 출력 ( -t )

$ strace -t ls



**시스템 콜 통계 정보 생성( -c )

$ strace -c ls /home







strings : 프로그램(실행가능한 바이너리=명령어) 안에서 사용된 문자열을 출력



옵션

-a : 파일을 검색하고 데이터 섹션까지 검색

-f : 각 문자열 전에 파일명 출력

-t={o,d,x} : 문자열의 위치를 8,10,16진수로 출력

-n 숫자 : 숫자 bytes 이상의 문자열 출력



# my_data.bin 파일에 포함된 길이 8바이트 이상의 문자열 출력

strings -n 8 my_data.bin



# 인코딩 변경(-e): single-8bit-byte character

ex) s=7-bit, S=8-bit, {b,l}=16-bit, {B,L}=32-bit

strings -e S my_data.bin







/etc/resolv.conf

-> 네임서버 설정과 기본적으로 사용할 도메인명을 설정,

; generated by /sbin/dhclient-script

search uzuro.com

nameserver 168.126.63.1

nameserver 168.126.63.2 







/etc/modprobe.conf

https://ko.wikipedia.org/wiki/Modprobe





scp 명령어를 이용한 파일 복사 및 전송

 

  ssh에서 제공되는 scp 명령어를 통해 로컬서버↔원격서버 로의 파일을 간단하게 전송할 수 있다.

 

 1. 사용방법

    1) 원격 서버 → 로컬 서버로 파일 전송

        # scp [옵션] [계정명]@[원격지IP주소]:[원본 경로 및 파일] [전송받을 위치]



        예제1) IP 111.222.333.444 서버의 abc라는 계정으로 /home/abc/index.html 파일을 로컬서버 /home/me/ 디렉토리에 전송 받기

                    # scp abc@111.222.333.444:/home/abc/index.html /home/me/

 

    2) 로컬 서버 → 원격 서버로 파일 전송

        # scp [옵션] [원본 경로 및 파일] [계정명]@[원격지IP주소]:[전송할 경로]



        예제2) 로컬서버 /home/me/wow.html 파일을 IP 111.222.333.444 서버의 /home/abc/ 디렉토리에 전송 하기

                   # scp /home/me/wow.html abc@111.222.333.444:/home/abc/

 

    3) ssh포트를 기본 22번으로 사용하고 있지 않는 서버로의 전송



        예제3) 2222번인 SSH포트를 사용한다면 아래와 같이 –P 옵션과 포트번호를 넣어준다.

                  # scp –P 2222 abc@111.222.333.444:/home/abc/index.html /home/me/

                  # scp –P 2222 /home/me/wow.html abc@111.222.333.444:/home/abc/

 

        [주의사항]

        옵션중에 –P와 –p가 있으니 대/소문자 확인을 하여야 한다.

        -P : 포트번호를 지정함

        -p : 원본파일 수정/사용시간 및 권한을 유지함

        -r : 하위 디렉토리 및 파일 모두 복사함




locate

: 다양한 패턴의 파일들을 찾고자 할 때, 특정 패턴에 해당하는 파일들의 위치를 검색함.

-> 특정패턴의 모든 파일 가운데 특정 문자열에 해당하는 파일들을 모두 검색하고자 할 때 사용



ex)

locate *.log

sss@gukii:~$ locate *.log | sort -n | xargs ls -lsh

8.0K -rw-r--r-- 1 root root 5.8K Feb  7 17:27 /var/log/alternatives.log

8.0K -rw-r--r-- 1 root root 7.3K Feb  7 17:28 /var/log/apt/history.log

 44K -rw-r----- 1 root adm   42K Feb  7 17:28 /var/log/apt/term.log

 92K -rw-r--r-- 1 root root  92K Feb  7 17:28 /var/log/dpkg.log



locate -n 10 *.conf

sss@gukii:~$ locate -n 10 *.conf | sort -n | xargs ls -lsh

4.0K -rw-r--r-- 1 root root 3.0K Sep 23 01:13 /etc/adduser.conf

8.0K -rw-r--r-- 1 root root 7.7K Sep 23 01:14 /etc/ca-certificates.conf

4.0K -rw-r--r-- 1 root root 2.9K Nov 11  2015 /etc/debconf.conf

4.0K -rw-r--r-- 1 root root  604 Jul  3  2015 /etc/deluser.conf

   0 -rw-r--r-- 1 root root  280 Jun 20  2014 /etc/fuse.conf

4.0K -rw-r--r-- 1 root root 2.6K Feb 19  2016 /etc/gai.conf

8.0K -rw-r--r-- 1 root root 4.7K Mar 17  2016 /etc/hdparm.conf

   0 -rw-r--r-- 1 root root   92 Oct 23  2015 /etc/host.conf

4.0K -rw-r--r-- 1 root root  771 Mar  6  2015 /etc/insserv.conf

   0 -rw-r--r-- 1 root root  110 Sep 23 01:13 /etc/kernel-img.conf



locate *.conf | grep hdparm

sss@gukii:~$ locate -n 10 *.conf | grep hdparm | sort -n | xargs ls -lsh
8.0K -rw-r--r-- 1 root root 4.7K Mar 17  2016 /etc/hdparm.conf


--> 현재 시스템에 존재하는 모든 파일들을 대상으로 하기 때문에 매우 유용한 명령어이다.



file

: 지정된 파일의 종류(타입)을 확인하는 명령어, /usr/share/file 디렉토리의 magic 파일을 참조하여 파일종류 표시



옵션

-C : 매직파일의 포맷을 검사하는 옵션

-f 목록파일 : 많은 파일들을 한번에 확인하기 위하여 파일리스트인 목록파일을 만들어서 그 안에 입력된 모든 파일을 한꺼번에 확인하는 옵션

-m 매직파일 : 지정된 매직파일로 대상파일을 확인하는 것.


ex)

[root@test ~]# file temp.list

temp.list: ASCII text, with no line terminators



type

: 지정된 명령어가 쉘에 내장된 명령어인지/ 외부명령어인지/ alias 인지 확인





ex)

[root@test ~]# type tail

tail is hashed (/usr/bin/tail)

[root@test ~]# 

[root@test ~]# type find

find is /usr/bin/find

[root@test ~]# 

[root@test ~]# type smartctl

smartctl is /usr/sbin/smartctl

[root@test ~]# 

[root@test ~]# type cp

cp is aliased to `cp -i'

[root@test ~]# type scp

scp is /usr/local/openssh/bin/scp



cut

: 텍스트 혹은 문장에서 하나 이상의 부분을 제거하여 원하는 입력폼으로 재생성할 때 사용



옵션

-c : 지정한 컬럼 출력

-f : 지정한 필드 출력

-d : 구분자



ex)

cut -c 2-5 /etc/passwd

/etc/passwd 파일의 2-5번째 문자까지 출력



cut -f 3 anaconda-ks.cfg

anaconda-ks.cfg 파일의 3번째 필드 출력(필드구분 tab)



cut -f 2 -d : /etc/passwd

/etc/passwd파일의 2번째 필드 출력(필드구분 ':')



chattr/lsattr



+/- : + : 속성 추가, - : 속성 제거



옵션

i : read-only 속성



ex)

[root@test ~]# touch testfile

[root@test ~]# 

[root@test ~]# chattr +i testfile 

[root@test ~]# 

[root@test ~]# lsattr testfile 

----i-------- testfile

[root@test ~]# 

[root@test ~]# echo Hi! > testfile 

-bash: testfile: 허가 거부됨

[root@test ~]# 

[root@test ~]# chattr -i testfile 

[root@test ~]# lsattr testfile 

------------- testfile

[root@test ~]# echo Hi! > testfile 

[root@test ~]# 

[root@test ~]# cat testfile 

Hi!





mkinitrd

: make init ramdisk 생성 명령어(커널이미지 생성 명령어)

/boot 디렉토리 하위에 kernel-version 파일을 initrd-image로 변경하여 준다. 여기서 initrd-image는 램디스크라고도 불리는데, 그 이유는 리눅스 부팅과정 중 BIOS에 의해 호출된 GRUB 부트로더가 실행되며 커널이미지를 RAM에 적재하기 때문이다.



사용법

mkinitrd -옵션 <initrd-image> <kernel-version>



옵션

--builtin = module : 모듈이 모듈형태로 동작하는 것이 아니라 커널 내부 동작해야 하는 모듈이면 이 옵션을 사용하면 될 것이다.



-f : initrd-image 이름이 이미 존재하면 덮어쓰기를 하게 해준다.



-v : verbose 모드로, 생성되는 과정 혹은 생성된 후 block 수를 화면에 return한다.



--fstab=fstab : 기본적으로 /etc/fstab를 참조하지만 자신이 만든 fatab파일을 참조하게 만들 때 사용한다.



--preload=module : initrd가 실행할 때 SCSI모듈이 올라오는 것을 기준으로 SCSI모듈 전에 실행될 모듈을 지정할 때 사용한다.



--with=module : initrd가 실행할 때 SCSI모듈이 올라오는 것을 기준으로 SCSI모듈 후에 실행 될 모듈을 지정할 때 사용한다.



ex)

[root@localhost boot]# cat grub/grub.conf 

# grub.conf generated by anaconda

...

title CentOS (4.9.48-29.el6.x86_64)

	root (hd0,0)

	kernel /vmlinuz-4.9.48-29.el6.x86_64 ro root=UUID=eb81650e-2c63-400c-be02-7c3deee155fa rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=128M  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet

selinux=0

initrd /initramfs-4.9.48-29.el6.x86_64.img

...

---> mkinitrd -v -f initranfs-4.9.48-29.el6.x86_64.img vmlinuz-4.9.48-29.el6.x86_64



반대로 생성된 커널이미지에 ahci 모듈이 있는지 확인하려면,

cp -a /boot/initramfs-2.6.32-573.el6.x86_64.img /test/

gzip -dc /test/initramfs-2.6.32-573.el6.x86_64.img | cpio -id

149971 blocks

[root@localhost ata]# pwd

/test/lib/modules/4.9.48-29.el6.x86_64/kernel/drivers/ata

[root@localhost ata]# ll | grep ahci

-rwxr--r-- 1 root root 17048 Mar 22 00:23 acard-ahci.ko

-rwxr--r-- 1 root root 11360 Mar 22 00:23 ahci_platform.ko

-rwxr--r-- 1 root root 21368 Mar 22 00:23 libahci_platform.ko




cpio



옵션

i     압축해제하라는 옵션

o    압축 생성 옵션

p    표준입력에서 파일명을 읽는다.

B    5120 bytes블럭단위로 입출력한다.

c    아스키 형식으로 헤더정보를 읽고 쓴다.

d    없는 디렉토리는 생성한다.

u    기존파일과 겹치면 덮어쓰지 않는다.

m    파일의 변경시간을 그대로 유지한다.

v    파일명 목록을 출력한다.

h    헤더의 형식을 tar와 같이 읽고 쓴다.

x    장치파일도 읽고 쓴다.



ex) cpio를 이용한 특정 확장자 파일만 압축

#find . -name '*.c' -print | cpio -o > data.cpio

#ls | cpio -o > ./test.cpio



ex) cpio 파일 풀기

-i cpio로 백업한 data를 restore 한다

-o 출력 - 묶을때

-p 통과모드

 -d restore중 필요한 디렉토리를 자동으로 생성시킨다

-m 백업 되있는 data들의 날짜, 시간을 그대로 유지한다

-v verbose



#cpio -idmv < test.cpio



ex) gz으로 압축되어 있는 것 풀기

gunzip targetfile.cpio.gz

cpio -idmv < targetfile.cpio



ex) cpio로 파일 옮기기

디렉토리 또는 파일시스템을 대량으로 옮겨야 할 경우

#find /old_directory -depth | cpio -pdmv /new_directory





mknod

장치파일(FIFO(p), Block(b), Character(c,u)) 생성(fdisk로 디바이스 파티션 생성한 후에도 /dev/sdxN이 보이지 않을 때 사용)

*모든 장치파일에는 Major Number와 Minor Number가 존재



사용법

mknod [옵션] [장치명] [타입] [주번호 부번호]



옵션

-m : 퍼미션 지정(chMod)



ex)

[root@localhost dev]# ll | grep sd

lrwxrwxrwx  1 root root           4 Oct  7 21:44 root -> sda3

brw-rw----  1 root disk      8,   0 Oct  7 21:44 sda

brw-rw----  1 root disk      8,   1 Oct  7 21:44 sda1

brw-rw----  1 root disk      8,   2 Oct  7 21:44 sda2

brw-rw----  1 root disk      8,   3 Oct  7 21:44 sda3

[root@localhost dev]# mknod -m 660 /dev/sda5 b 8 5

[root@localhost dev]# ll | grep sd

lrwxrwxrwx  1 root root           4 Oct  7 21:44 root -> sda3

brw-rw----  1 root disk      8,   0 Oct  7 21:44 sda

brw-rw----  1 root disk      8,   1 Oct  7 21:44 sda1

brw-rw----  1 root disk      8,   2 Oct  7 21:44 sda2

brw-rw----  1 root disk      8,   3 Oct  7 21:44 sda3

brw-rw----  1 root root      8,   5 Mar 22 00:53 sda5

[root@localhost dev]# chown root.disk sda5

[root@localhost dev]# ll | grep sd
lrwxrwxrwx  1 root root           4 Oct  7 21:44 root -> sda3
brw-rw----  1 root disk      8,   0 Oct  7 21:44 sda
brw-rw----  1 root disk      8,   1 Oct  7 21:44 sda1
brw-rw----  1 root disk      8,   2 Oct  7 21:44 sda2
brw-rw----  1 root disk      8,   3 Oct  7 21:44 sda3
brw-rw----  1 root disk      8,   5 Mar 22 00:53 sda5

참고) SATA 계열 Block Major Number : 8, Minor Number : 0~15,16~31,...     IDE 계열 Block Major Number : 3





tee

: 리눅스 화면과 파일에 동시 출력

400px-Tee.svg.png

ex1) 표준출력을 화면출력&파일기록

명령어 | tee <파일명>



ex2) 표준출력을 화면출력&파일기록 (단, 기존내용 유지하고 내용 추가 (-a(append))

명령어 | tee -a <파일명>



ex3) 출력+오류를 화면출력&파일기록 (오류메시지 포함하여 파일로 저장)

명령어 2>&1 | tee <파일명>





blkid

/sbin/blikd

: 블럭 디바이스 속성 조회 도구 ( HDD UUID / FS TYPE / LABEL 등 조회 )



ex)

[root@~]# blkid

/dev/sda7: UUID="0028762c-007f-46c3-8a1a-1fb10018d02d" TYPE="ext3" 

/dev/sda6: UUID="32b0124a-f6ad-4152-b02b-9f55f98a5d41" TYPE="ext3" 

/dev/sda5: UUID="644697a9-2e18-4c98-9a93-0a0a8976c048" TYPE="ext3" 

/dev/sda3: TYPE="swap" 

/dev/sda2: UUID="a3860334-c4a8-4371-adb9-db080667eb77" TYPE="ext3" 

/dev/sda1: UUID="f701d842-adfc-41f6-9bb9-53e5052d94fc" TYPE="ext3" 

/dev/sdb2: UUID="a3860334-c4a8-4371-adb9-db080667eb77" TYPE="ext3" 

/dev/sdb1: UUID="f701d842-adfc-41f6-9bb9-53e5052d94fc" TYPE="ext3" 

/dev/sdb5: UUID="644697a9-2e18-4c98-9a93-0a0a8976c048" TYPE="ext3" 

/dev/sdb6: UUID="32b0124a-f6ad-4152-b02b-9f55f98a5d41" TYPE="ext3" 

/dev/sdb7: UUID="0028762c-007f-46c3-8a1a-1fb10018d02d" TYPE="ext3" 

/dev/sdb3: TYPE="swap" 



--> 평소엔 잘 사용하지 않는 명령어이지만 부팅이 되지 않을 때 /boot/grub2/grub.cfg 파일을 확인하거나 /etc/fstab 파일을 확인할 때 사용됨.





 # Reference
 https://gukii.tistory.com/19