---
share: "true"
---
## 0. 이번 장에서 기억할 것
- `if / else if / else` 의 괄호 안에는 **최종적으로 boolean 값 하나**가 들어간다.
- `switch` 는 **값 하나**에 대해 여러 경우를 나눌 때 쓰고, JVM이 **점프 테이블**로 최적화할 수도 있다.
- `while` 은 **조건 중심**, `for` 는 **횟수/카운터 중심** 반복에 어울린다.
- `break` 는 **루프 전체 중단**, `continue` 는 **이번 회차만 건너뛰고 다음 반복으로 이동**한다.
- `label + break` 를 쓰면 **중첩 루프에서 바깥 루프까지 한 번에 탈출**할 수 있다.

---

## 1. 내가 이해한 한 줄 요약
### 1-1. if / else if / else
- 여러 조건을 위에서부터 차례대로 검사하고,  마지막 `else` 는 **그 외 모든 경우**를 처리한다.
- 조건식 안에서 여러 비교/논리 연산을 해도,  결국엔 **true / false 한 번** 결정해서 분기한다.
    
### 1-2. switch
- 한 변수의 값에 따라 **여러 "딱 떨어지는 값(case)"** 으로 분기할 때 사용한다.
- `default` 는 어떤 case 도 맞지 않을 때의 **기본 처리(else 역할)** 이다.
    
### 1-3. while / for / do-while
- `while` : “이 조건을 만족하는 동안 계속”이라는 **조건 중심 루프**.
- `for` : “언제부터 언제까지, 몇 번” 이 딱 정해진 **횟수/인덱스 중심 루프**.
- `do-while` : **최소 한 번은 실행**되고 나서 조건을 검사하는 루프.
    
### 1-4. break / continue / label
- `break` : 현재 돌고 있는 **반복문 전체를 종료**한다.
- `continue` : **현재 회차만 건너뛰고**, 다음 반복으로 넘어간다.
- `label + break` : **label 이 붙은 바깥 루프까지** 한 번에 탈출할 수 있다.
    
---

## 2. 개념 정리
### 2-1. if / else if / else
#### 2-1-1. if 조건식과 boolean
- 예시:
``` java
int errorCount = ...;
String serverStatus = ...;  
if (errorCount >= 1 && "ACTIVE".equals(serverStatus)) {     // 알림 전송 }
```

- `errorCount >= 1` → boolean
- `"ACTIVE".equals(serverStatus)` → boolean
- `&&` 로 묶어서 최종 boolean 하나 → `if` 괄호 안으로 들어간다.
- `"ACTIVE".equals(serverStatus)` 형태는 `serverStatus` 가 `null` 이어도 NPE 없이 false 를 돌려줘서 더 안전하다.
    

#### 2-1-2. else if / else
- 여러 조건을 순서대로 검사할 때:
``` java
double responseTime = ...; // 초
if (responseTime < 0.5) {
     // FAST 
} else if (responseTime < 2.0) {
     // NORMAL
} else {
     // SLOW 
}
```
- `else` 는 “위 조건에 모두 안 걸린 **나머지 전부**” 를 처리한다.
- 운영/모니터링 관점에서는 예상 못 한 값이 와도 최소한의 **기본 처리 + 로그** 를 남기는 안전망 역할.
    
---

### 2-2. switch 문
#### 2-2-1. 기본 형태와 사용 예
``` java
int statusCode = ...;  
switch (statusCode) {
     case 200:      
        // OK     
	    break;     
	case 400:         
		// BAD_REQUEST
		break;     
	case 500:         
		// SERVER_ERROR         
		break;     
	default:         
		// UNKNOWN         
		break; 
}
```
- `default` : if 문의 `else` 와 같다.    
- 특정 값들(200, 400, 500 …)에 대해 **각각의 분기**가 필요할 때 가독성이 좋다.
    
#### 2-2-2. if / else if 와의 차이 (JVM 관점)
- `if / else if`
    - “200이냐?” → 아니면 “400이냐?” → 아니면 “500이냐?” …
    - 조건을 **순서대로 하나씩 검사**하는 구조.
- `switch (int, enum 등)`
    - JVM 이 `tableswitch` / `lookupswitch` 를 사용해  **점프 테이블 형태**로 최적화할 수 있다.
    - 즉, 값 하나를 **인덱스처럼** 써서  어디로 점프할지 **한 번에 결정**할 수 있다.
-  내 정리:
	- if / else if : 조건을 하나씩 순서대로 비교
	- switch : 값 하나에 대한 여러 경우를 **테이블처럼 관리 + 분기**
#### 2-2-3. break 와 fall-through
``` java
int statusCode = ...;

switch (statusCode) {
    case 200:
        // OK
        break;
    case 400:
        // BAD_REQUEST
        break;
    case 500:
        // SERVER_ERROR
        break;
    default:
        // UNKNOWN
        break;
}

```
- `statusCode == 400` 이면 `BAD_REQUEST`, `SERVER_ERROR` 출력    
- `case` 는 "시작 위치를 알리는 라벨"일 뿐,  아래로 내려가는 걸 막지 못한다.
- `break` 를 만나기 전까지 **아래 줄들이 계속 실행되는 것**을  **fall-through** 라고 한다.
    
---

### 2-3. while / for / do-while
#### 2-3-1. while – 조건 중심
``` java
int retry = 0;
boolean success = false;

while (!success && retry < 3) {
    success = sendRequest(); // boolean 리턴
    retry++;
}

```
- “이 조건을 만족하는 동안 계속” 이라는 느낌.
- 서버 상태, 큐에 데이터가 남아 있는지 등 **상태 변화에 따라 종료 시점이 결정**될 때 적합.
    

#### 2-3-2. for – 횟수/인덱스 중심
`for (int i = 0; i < list.size(); i++) {     // list.get(i) 처리 }`
- “언제부터 언제까지, 몇 번” 이 딱 정해져 있을 때 사용.
- 초기화 / 조건 / 증감을 한 줄에서 볼 수 있어서 인덱스 기반 순회에 읽기 좋다.
- `for` 는 꼭 `int` 지역변수를 선언해야 하는 건 아니다.
- 본질적으로는 **초기화 + 조건 + 증감이 한 줄에 모인 while** 로 볼 수 있다.

#### 2-3-3. do-while – 최소 한 번 실행
`int i = 0; do {     // 최소 한 번은 실행된다     i++; } while (i < 3);`
- 조건 검사 전에 **몸통이 한 번 실행**된다.
- “메뉴를 최소 한 번 보여주고, 계속할지 물어보기” 같은 상황에 사용.
    
---

### 2-4. break / continue / label
#### 2-4-1. break
```java
for (int i = 1; i <= 5; i++) {
    if (i == 3) {
        break;
    }
    System.out.println(i);
}
```
- 출력: `1`, `2`
- `i == 3` 에서 `break` 를 만나면  **해당 for 문 전체를 종료**한다.
- 내가 이해한 정리:
	- `break` 는 **루프 중단** (현재 반복문 전체 종료)

#### 2-4-2. continue
```java
for (int i = 1; i <= 5; i++) {
    if (i == 3) {
        continue;
    }
    System.out.println(i);
}
```
- 출력: `1`, `2`, `4`, `5`
- `i == 3` 일 때는 `println` 을 건너뛰고,  **증감식 → 다음 반복**으로 넘어간다.
- 내가 이해한 정리:
	- `continue` 는 **이번 루프만 건너뛰고 다음 루프를 실행**한다.

#### 2-4-3. label + break (중첩 루프에서 탈출)
```java
outer:
for (int i = 0; i < 3; i++) {      // 바깥 루프
    for (int j = 0; j < 3; j++) {  // 안쪽 루프
        if (i == 1 && j == 1) {
            break outer;           // outer 라벨이 붙은 for 전체 종료
        }
    }
}
```
- 평범한 `break` 는 **가장 안쪽 루프 하나만 종료**한다.
- `break outer;` 는 **outer 라벨이 붙은 바깥 for 문 전체를 종료**한다.
- 내가 이해한 정리:
	- label 이 붙은 `break` 는  **label 이 붙은 반복문을 통째로 빠져나갈 수 있다.**
	
---

## 4. 헷갈렸던 포인트 메모
- `if` 괄호 안에 여러 자료형이 들어가는 게 아니라, 여러 비교/논리 연산을 해서 **결국 boolean 하나**가 들어간다.
- `switch` 도 논리적으로는 "case 들 중 하나를 고른다"지만, JVM 은 상황에 따라 **점프 테이블로 한 번에 분기**할 수 있다.
- `switch` 에서 `break` 를 빼먹으면 **fall-through** 로 아래 case 가 같이 실행될 수 있다.
- `for` 는 꼭 int i 를 선언해야 하는 문법이 아니고, **초기화 + 조건 + 증감이 한 줄에 모인 while** 로 이해해도 된다.
- `break` 는 가장 안쪽 루프만 끊고, **바깥 루프까지 한 번에 끊으려면 label 이 필요**하다.

---

## 5. 정리해봅시다 (스스로 설명해보기)
> O / △ / X 기준:  
> O = 내 말로 60초 안에 설명 가능
1. `if ( ... )` 괄호 안에 들어가는 값의 타입은 무엇인가?  
	- 여러 비교/논리 연산이 어떻게 최종적으로 그 타입 하나로 모이는지 설명해보자.
2. `switch` 문이 `if / else if` 에 비해
    - 가독성 측면에서, JVM 실행 관점에서  가지는 차이를 설명해보자.
3. `while` 과 `for` 의 차이를  “조건 중심 / 횟수 중심” 이라는 키워드로 설명해보자.
4. `break` 와 `continue` 의 차이를  “루프 전체 종료 vs 이번 회차만 건너뛰기” 관점에서 설명해보자.
5. 2중 for 루프에서 특정 값을 찾는 순간  **바깥 루프까지 한 번에 탈출**해야 할 때,  `label + break` 를 어떻게 쓸 수 있는지 예시를 들어 설명해보자.

---

## 궁금한 점
- switch 문을 사용했을 때 JVM에서 최적화를 위해 점프테이블을 사용한다고 했는데 어떠한 기준으로 점프테이블을 사용하는지 궁금함