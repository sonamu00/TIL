---
share: "true"
---
## 1. 중첩 클래스
- 어떤 클래스 A가 있고, 그 안에 또 다른 클래스 B를 선언하면 B는 “A의 내부에서만 쓰라고 만든 클래스”라는 의미가 되며, 이것을 중첩 클래스 또는 내부 클래스라고 부른다.
- 코드를 모듈화해서 “밖에서는 몰라도 되는 타입”을 감추고 싶을 때 사용하며, 외부 클래스와 긴밀하게 연결된 작은 역할 객체를 만들 때 쓴다.
    
---

## 2. 중첩 클래스 4종류 정리
1. **static 중첩 클래스 (static nested class)**
	- 문법: `class Outer { static class Inner { ... } }`
	- `static`이 붙어 있어서 **Outer 인스턴스 없이도** `new Outer.Inner()`로 바로 생성 가능하다.
	- 외부 인스턴스 필드에는 직접 접근할 수 없고, 외부의 `static` 멤버에는 접근 가능하다.
	- 실무에서 `Map.Entry` 같은 “부가 타입”을 외부 클래스 안에 함께 두는 패턴과 비슷한 역할을 한다.
	- JDK에서도 `java.util.Map` 안에 `Map.Entry<K,V>`라는 **정적 중첩 인터페이스**가 있는데, “A map entry (key-value pair).” 즉 “키와 값의 한 쌍을 표현하는 엔트리”라고 설명한다.([Oracle Docs](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Map.Entry.html?utm_source=chatgpt.com "Map.Entry (Java SE 20 & JDK 20)"))
	    
2. **인스턴스 내부 클래스 (inner class)**
	- 문법: `class Outer { class Inner { ... } }` (static 없음)
	- 항상 어떤 `Outer` 인스턴스에 묶여 있으며, `new Outer.Inner()`를 만들려면 먼저 `Outer outer = new Outer();`를 만든 다음 `Outer.Inner inner = outer.new Inner();` 형식으로 생성해야 한다.
	- 외부 인스턴스의 필드와 메서드에 자연스럽게 접근할 수 있어서 외부 객체와 강하게 연결된 동작을 표현할 때 쓴다.
	- 하지만 외부 인스턴스에 대한 숨겨진 참조가 생기므로, 메모리 누수나 참조 관계가 복잡해질 수 있어 남용은 잘 안 한다.

3. **지역 클래스 (local class)**
	- 메서드나 블록 안에서 `class Local { ... }`처럼 선언하는 클래스이다.
	- 해당 메서드 안에서만 사용할 수 있는 “한정된 용도”의 타입이며, 아주 국지적인 헬퍼 로직을 캡슐화하고 싶을 때 쓴다.
	- 지역 변수(특히 effectively final 변수)를 캡쳐해서 사용할 수 있지만, 코드가 복잡해지기 쉬워서 실무에서는 “정말 간단한 경우”에만 쓰는 편이다.
    
4. **익명 클래스 (anonymous class)**
	- 이름 없이 바로 `new 인터페이스이름() { ... 구현 ... }` 또는 `new 부모클래스이름() { ... 오버라이드 ... }` 형태로 만드는 클래스이다.
	- 실무에서 콜백, 리스너, 스레드 작업 등 “한 번만 쓸 구현체”를 만들 때 자주 쓰였다.
---

## 3. 익명 클래스와 람다의 관계
- 예전 자바 코드에서는 콜백이나 간단한 인터페이스 구현을 위해 익명 클래스를 많이 썼는데, Java 8 이후에는 함수형 인터페이스(예: `Runnable`, `Comparator<T>` 등)에 대해서는 **람다식**을 쓰는 것이 일반적이다.
- 같은 의미의 코드 예시(개념만 이해용):
    - 익명 클래스: `new Runnable() { @Override public void run() { 작업(); } }`
    - 람다식: `() -> 작업();`
- **정리**: “익명 클래스의 주요 사용처 중 상당수가 람다로 대체되었다”라고 이해하면 된다.
    
---

## 4. 실무·CS 관점에서 정리
- **캡슐화 관점**: 특정 클래스 안에서만 쓰이는 타입을 외부로 노출시키지 않고 내부에 감춰서, API를 더 간결하게 만들 수 있다 (Inner Nested)
- **아키텍처/설계 관점**: 외부 클래스와 강하게 결합된 작은 역할(예: 엔트리, 상태를 표현하는 enum 비슷한 도우미, 빌더 내부의 스텝 객체 등)을 함께 묶어 설계 의도를 드러낼 수 있다 (Static Nested )
- **실무 코드 관점**:
    - static 중첩 클래스: `Map.Entry` 같은 “부가 구조”를 표현할 때 사용, 외부 인스턴스와 독립적이다.
    - 익명 클래스/람다: 스레드 작업(`Runnable`), 이벤트 리스너, 정렬 시 `Comparator` 구현 등 “콜백 기반 API”에서 핵심 도구로 쓰인다.
- **운영체제/스레드 관점**: 익명 클래스나 람다로 만든 `Runnable` 구현체는 결국 OS 스레드 또는 JVM 스레드에 올려서 실행되는 작업 단위이며, JDK 17 문서가 말하듯이 “instances are intended to be executed by a thread” 즉 스레드가 실행할 코드 블록을 담는 그릇이다.([Oracle Docs](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Runnable.html?utm_source=chatgpt.com "Runnable (Java SE 17 & JDK 17)"))
    
---

## 5. 언제 쓰고 언제 피할까?
- **쓰는 편이 좋은 경우**
    - 1. 특정 클래스 안에서만 의미가 있는 타입(예: `Outer`의 상태를 표현하는 작은 enum 형태, 헬퍼 클래스)을 외부로 노출하고 싶지 않을 때
    - 2. 콜백, 리스너, 스레드 작업처럼 “한 번만 필요하거나 이름을 따로 줄 필요가 없는 구현”이 있을 때 (익명 클래스 또는 람다)
            
- **피하는 편이 좋은 경우**
    - 1. 내부 클래스가 너무 복잡해지고 외부와의 관계가 꼬이기 시작하면, 차라리 독립 클래스로 분리하는 것이 가독성과 테스트에 더 좋다.
    - 2. 외부 인스턴스를 잡고 있어서 메모리 누수가 생기거나, 참조 구조가 헷갈리는 경우 (특히 GUI, 긴 생명주기 객체에서 주의)
