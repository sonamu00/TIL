---
share: "true"
---

## 1. 패키지란 무엇인가
* 패키지는 자바에서 클래스를 논리적으로 묶기 위한 이름 공간(네임스페이스)이다.
* OS 관점에서 `com/example/app` 는 단순한 디렉터리 구조지만, 자바 관점에서는 `com.example.app` 이라는 하나의 패키지 이름이다.
* 폴더와 패키지는 보통 1:1로 매핑되지만 개념이 다르다.
	- 폴더
		- 물리적으로 파일이 저장된 위치를 나타내는 OS 레벨 개념
		- 상위가 하위를 **포함** 하는 구조
	- 패키지
		- JVM과 컴파일러가 클래스를 분류하고 찾기 위해 사용하는 논리적 단위
		- 상위가 하위를 포함한다는 개념이 없음
* 자바에서 클래스의 정식 이름은 `패키지명.클래스명` 형태이며, 예를 들어 `com.example.Main` 은 `com/example/Main.class` 파일로 매핑된다.

---

## 2. 패키지 선언의 규칙과 역할
* `package` 선언은 소스 파일의 **가장 첫 줄**에 한 번만 올 수 있다.
* 하나의 `.java` 파일에는 **하나의 패키지 선언**만 허용된다.
* 패키지 이름과 실제 소스 파일이 위치한 폴더 구조가 일치해야 `javac`, `java` 가 정상적으로 클래스를 찾을 수 있다.
* 패키지 이름은 관례적으로 모두 소문자로 작성하며, 보통 거꾸로 쓴 도메인(`com.company.project`)을 사용한다.
	* 대소문자를 섞으면 OS마다 디렉터리 대소문자 처리 방식이 달라 문제를 일으킬 수 있기 때문에 소문자로 통일하는 것이 안전하다.
* 패키지 이름에 자바 예약어를 쓸 수 없다.
* 패키지 이름을 `java` 로 시작하는 것은 금지된다.
	- `java.*`, `javax.*` 등은 JDK 표준 라이브러리 전용 네임스페이스이기 때문에, 사용자 코드가 이 영역을 침범하여 시스템 클래스인 척 위장하는 일을 막기 위해서이다.
	- `java` 로 시작하는 패키지를 쓰면 `SecurityException` 을 던지도록 되어 있음
* 상위 패키지와 하위 패키지는 자바 언어 차원에서 아무 상관 관계가 없다.
	* `com.example` 과 `com.example.sub` 는 전혀 다른 패키지이다.
	* default(package-private) 접근 제어도 “같은 패키지냐 아니냐”만 보고, 상위/하위 패키지는 고려하지 않는다.

---

## 3. import와 static import
### 3-1. 기본 import 규칙
* 같은 패키지에 있는 클래스는 `import` 없이 바로 클래스 이름으로 사용할 수 있다.
* `java.lang` 패키지(예: `String`, `Integer`, `System` 등)는 자동으로 import 되므로 별도 `import` 가 필요 없다.
* 그 외의 패키지 클래스는 `import 패키지.클래스명;` 혹은 `import 패키지.*;` 를 통해 가져와야 한다.

```java
import com.example.user.User;       // 특정 클래스
import java.util.*;                 // 패키지 내 모든 클래스(하위 패키지는 포함 안 됨)

public class Sample {
    public static void main(String[] args) {
        User user = new User();
    }
}
```
* `import java.util.*;` 는 `java.util` 패키지의 클래스들만 가져오며, `java.util.concurrent.*` 는 별도로 import 해야 한다.

### 3-2. 이름 충돌과 완전 수식 이름
서로 다른 패키지에 동일한 클래스 이름이 있을 때는 충돌을 주의해야 한다.

```java
import java.util.Date;
import java.sql.*;  // 여기도 Date가 있음

public class Sample {
    public static void main(String[] args) {
        Date now = new Date();
    }
}
```
* 위처럼 `java.util.Date`와 `java.sql.Date`가 동시에 범위에 들어오면, 컴파일러는 어느 Date를 쓸지 모호해 한다.
* 이런 경우 한 쪽만 import 하고, 다른 쪽은 `java.sql.Date` 처럼 패키지명을 포함한 완전 수식 이름으로 사용해야 한다.
* 실무에서는 와일드카드 `*` 남발보다는 필요한 클래스만 명시적으로 import 하거나, 이름이 겹치는 타입은 항상 패키지명을 붙여 쓰는 것이 유지보수에 유리하다.

### 3-3. static import
* `static import` 는 다른 클래스의 `static 필드`나 `static 메서드`를 사용할 때 클래스명을 생략하고 바로 이름으로 쓰게 해주는 문법이다.

```java
import static java.lang.Math.max;
import static java.lang.Integer.MAX_VALUE;

public class Example {
    public static void main(String[] args) {
        int bigger = max(10, 20);      // Math.max 대신 max로 사용
        int limit = MAX_VALUE;         // Integer.MAX_VALUE 대신 MAX_VALUE로 사용
    }
}
```
* 같은 이름의 `static 멤버`가 현재 클래스 안에도 있다면, **현재 클래스의 것**이 우선 사용된다.


```java
import static java.lang.Integer.MAX_VALUE;

public class RangeUtils {
    static int MAX_VALUE = 100;

    public static void main(String[] args) {
        System.out.println(MAX_VALUE);  // 100이 출력된다.
    }
}
```
* 이름을 해석할 때 컴파일러는 “현재 클래스의 필드/메서드 → 상속된 멤버 → static import” 순서로 찾기 때문에, 현재 클래스의 `MAX_VALUE`가 우선시된다.

---

## 4. 패키지와 컴파일, 실행 흐름
* 어떤 클래스를 사용하려면, 그 클래스가 먼저 컴파일되고, 그 다음에 그 클래스를 사용하는 코드가 컴파일되어야 한다.
* 컴파일 시 `javac`는 `package` 선언을 보고 클래스의 정식 이름과 클래스 파일을 둘 경로를 결정한다.
* 실행 시 `java com.example.Main` 처럼 패키지 이름을 포함해 실행하면, JVM은 classpath 아래에서 `com/example/Main.class`를 찾아 로딩한다.
* 즉 소스 코드 상단의 `package` 선언은 “이 클래스가 어디에 속하는지”와 “JVM이 어디에서 이 클래스를 찾아야 하는지”를 결정하는 역할을 한다.

---

## 5. 접근 제어자 개요
자바에서 접근 제어자는 클래스, 생성자, 메서드, 필드에 붙여서 “어디까지 접근을 허용할지”를 결정하는 키워드이다.
* `public` : 어디에서나 접근 가능하다.
* `protected` : 같은 패키지에서는 접근 가능하고, 다른 패키지라도 자식 클래스라면 접근 가능하다.
* (default / package-private) : 접근 제어자를 명시하지 않았을 때로, 같은 패키지 안에서만 접근 가능하다.
* `private` : 선언된 클래스 내부에서만 접근 가능하며, 같은 패키지의 다른 클래스에서도 접근할 수 없다.

---

## 6. package-private(default)와 protected의 차이
### default(package-private)

```java
class Sample {
    int value;          // default (package-private)
    void doSomething() {// default (package-private)
    }
}
```
* 같은 패키지 내의 다른 클래스에서 접근 가능하다.
* 다른 패키지에서는 **상속을 받더라도** 접근할 수 없다.
* “이 패키지 안에서만 공유하는 내부용 API” 라는 의미를 갖는다.

### protected

```java
public class Parent {
    protected int value;
    protected void doWork() {}
}
```

* 같은 패키지의 다른 클래스에서 접근할 수 있다.
* 다른 패키지에 있더라도 `Parent`를 상속한 자식 클래스에서는 `value`와 `doWork()`에 접근할 수 있다.
* 즉 `protected`는 “패키지 + 상속 관계 모두를 고려한 제어자”이고, 상속을 의식해 설계된 접근 제어자라고 할 수 있다.

---

## 7. 접근 제어자를 사용하는 이유

### 7-1. 모든 것을 public으로 열어두었을 때의 문제

```java
public class UserAccount {
    public String id;
    public String password;
    public int point;
    public boolean isAdmin;
}
```

* 어디서나 마음대로 `point`, `isAdmin`, `password`를 바꿀 수 있다.
* 객체 자신이 “유효한 상태”를 유지할 수 없고, 누가 언제 값을 바꿨는지 추적하기 어려우며, 디버깅이 매우 힘들어진다.
* 여러 클래스, 여러 스레드가 동시에 필드를 바꾸면 상태가 꼬이기 쉬워지고, 사이드 이펙트가 커진다.
* 보안적으로도 비밀번호나 권한 관련 값 같은 민감한 정보가 아무 데서나 바뀔 수 있는 구조가 된다.

### 7-2. 캡슐화와 책임 분리

```java
public class UserAccount {
    private String id;
    private String password;
    private int point;
    private boolean isAdmin;

    public void chargePoint(int amount) { /* 검증, 로그, 트랜잭션 등 */ }
    public boolean matchPassword(String rawPassword) { /* 비밀번호 비교 로직 */ }

    void resetPointForTest() { /* 같은 패키지에서만 쓰는 테스트용 */ }
    protected void markAsAdmin() { /* 상속 구조 내에서만 쓰는 확장용 */ }
}
```

* `private` 필드로 객체의 상태를 숨기고, 외부에는 검증과 로깅이 포함된 `public` 메서드만 제공하면 객체 스스로 상태를 통제할 수 있다.
* 패키지 단위로 내부용(default, protected, package-private) API를 숨기면, 외부에서 건드려서는 안 되는 구현 디테일을 보호할 수 있다.
* 실무에서 “어떤 클래스를 import 했을 때 이 객체에서 어디까지 접근할 수 있는지”가 명확해지므로, 코드 읽을 때 책임 범위를 파악하기 쉽고, API 사용 범위도 자연스럽게 제한된다.
* 보안 측면에서는 비밀번호, 권한 플래그, 금액, 포인트 같은 민감한 필드는 반드시 `private`으로 감추고, 값 변경은 검증과 감사 로그가 들어 있는 서비스 메서드를 통해서만 일어나도록 만드는 것이 기본적인 방어선이다.
