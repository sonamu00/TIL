---
share: "true"
---
## 1. 어노테이션(Annotation) 기본 개념
- **정의**
    - 어노테이션은 **클래스, 메서드, 필드 등 코드 요소에 붙이는 메타데이터**이다.
    - JDK 17 문맥: “컴파일러가 오류 검출/경고 억제에 쓰거나, 컴파일·배포·런타임 시점에 다양한 처리를 하기 위한 추가 정보”.
- **역할**
    - **코드의 “의도와 설정”을 표현**
    - 이 정보를 **컴파일러 / 프레임워크 / 빌드 도구**가 읽어서 실제 동작을 수행한다.
    - 어노테이션 자체가 로직을 실행하는 게 아니라, **읽는 쪽(컴파일러, 프레임워크)** 이 의미를 해석하고 동작을 붙인다.
- **두 축으로 동작**
    - **컴파일 타임**: 컴파일러 + 어노테이션 프로세서
    - **런타임**: 리플렉션 + 프록시/AOP/프레임워크
        
---

## 2. 기본 어노테이션 3형제
### 2-1. `@Override`
- **정의**
    - “이 메서드는 상위 타입(부모 클래스/인터페이스)의 메서드를 오버라이드하려는 의도이다”를 컴파일러에 알려주는 어노테이션.
- **특징**
    - 컴파일러가 **오버라이딩이 맞는지 검증**한다.
        - 메서드 시그니처 오타, 파라미터 타입/개수 실수 → 컴파일 에러로 잡아줌.
    - `@Retention(SOURCE)`라서 **소스에서만 사용**되고 `.class`에도 남지 않는다.
- **포인트**
    - **동작을 바꾸는 게 아니라 “의도”를 명시해 버그를 컴파일 시점에 잡는 도구**이다.
        

### 2-2. `@Deprecated`
- **정의**
    
    - 더 이상 사용을 권장하지 않는 API에 붙이는 어노테이션.
        
- **역할**
    
    - IDE/컴파일러가 **경고를 띄우는 근거**가 된다.
        
    - Javadoc에 “왜 폐기되었는지 / 어떤 API로 갈아타야 하는지” 설명을 함께 적어 버전 관리와 마이그레이션을 돕는다.
        
- **실무 활용**
    
    - 기존 메서드를 바로 삭제하지 않고 **“뒤로 호환성 유지 + 앞으로는 새 API로 유도”**할 때 사용.
        

### 2-3. `@SuppressWarnings`

- **정의**
    
    - 지정한 이름의 **컴파일 경고를, 해당 요소 범위 안에서만 숨겨 달라**고 컴파일러에 요청하는 어노테이션.
        
- **예시**
    
    - `"unchecked"`: 제네릭 관련 경고 숨기기
        
    - `"deprecation"`: deprecated API 사용 경고 숨기기
        
    - `"rawtypes"`: raw type 경고 숨기기
        
- **포인트**
    
    - “프로젝트 전체에서 경고 끄기”가 아니라,
        
    - **위험을 알고 감수하는 코드 조각에만 범위를 좁혀서 조용히 만드는 용도**.
        

---

## 3. 메타 어노테이션 (어노테이션을 위한 어노테이션)

### 3-1. `@Retention`

- **역할**
    
    - “이 어노테이션 정보가 **언제까지 유지될지**”를 지정한다.
        
- **종류**
    
    - `SOURCE`
        
        - 소스에만 존재, 컴파일 후 사라짐.
            
        - 컴파일러용 힌트(`@Override` 등)에 사용.
            
    - `CLASS`
        
        - `.class` 파일까지는 남지만, 런타임 리플렉션으로는 보이지 않는다.
            
        - 기본값.
            
    - `RUNTIME`
        
        - 런타임에도 유지되어 **리플렉션으로 조회 가능**.
            
        - 스프링의 `@Transactional`, `@Repository`, `@Controller` 등은 모두 `RUNTIME` 이어야 한다.
            
- **핵심**
    
    - **리플렉션으로 읽고 싶으면 무조건 `RUNTIME`.**
        
    - 컴파일러에서만 쓰고 싶으면 `SOURCE`.
        

### 3-2. `@Target`

- **역할**
    
    - 어노테이션을 **어디에 붙일 수 있는지** 제한한다.
        
- **자주 쓰는 `ElementType`**
    
    - `TYPE`: 클래스, 인터페이스, enum, record
        
    - `METHOD`: 메서드
        
    - `FIELD`: 필드
        
    - `PARAMETER`: 파라미터
        
    - `TYPE_USE`: 타입이 사용되는 모든 위치(Java 8+)
        
- **의미**
    
    - 코드를 설계할 때 “이 어노테이션은 이런 용도로만 써라”라는 규칙을 **컴파일 규칙으로 강제**하는 역할.
        

### 3-3. `@Documented`

- **역할**
    
    - 이 어노테이션이 붙은 어노테이션을 사용하면,  
        그 어노테이션 정보가 **Javadoc 같은 API 문서에도 함께 표시**되게 만든다.
        
- **포인트**
    
    - “이 어노테이션은 **공개 API 계약의 일부**다”라는 의미.
        
    - 라이브러리 공개용 어노테이션에 많이 사용.
        

### 3-4. `@Inherited`

- **역할**
    
    - 클래스에 붙은 어노테이션을 **자식 클래스가 상속받도록** 한다.
        
- **특징**
    
    - 클래스 상속에서만 의미가 있고, 필드/메서드에는 적용되지 않는다.
        
    - `BaseController`에 붙은 어노테이션을, `extends BaseController` 한 하위 클래스도 **“붙은 것으로 간주”**하게 만들고 싶을 때 사용.
        

---

## 4. 커스텀 어노테이션 정의

- **기본 형태**
    

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface LogExecutionTime {
    String value() default "";
}
```

- **포인트**
    
    - `public @interface Name` 식으로 선언하면 **새 어노테이션 타입**을 정의하는 것.
        
    - 중괄호 안에 있는 “몸체 없는 메서드” 같은 것들이 어노테이션의 **속성(property)** 역할을 한다.
        
    - 속성 타입은 기본형, `String`, `Class`, `enum`, 다른 어노테이션, 이들의 배열만 허용.
        
    - 런타임에 프레임워크가 읽어야 하면 반드시 `@Retention(RUNTIME)`.
        

---

## 5. 리플렉션(Reflection)과 런타임 어노테이션

### 5-1. 리플렉션이란?

- **정의**
    
    - **프로그램이 실행 중에 자기 자신(클래스, 메서드, 필드)의 구조와 메타데이터(어노테이션 포함)를 조회하고, 메서드를 호출하거나 필드 값을 조작할 수 있게 해주는 기능**.
        
- **핵심 클래스**
    
    - `Class`, `Method`, `Field`, `Constructor` 등
        
    - 이들은 `AnnotatedElement`를 구현하고 있어서, `getAnnotation(...)`으로 어노테이션을 읽을 수 있다.
        

### 5-2. 리플렉션 + 어노테이션 사용 예

```java
Method method = UserService.class.getMethod("createUser");
LogExecutionTime ann = method.getAnnotation(LogExecutionTime.class);
if (ann != null) {
    // 이 메서드는 실행 시간을 로깅해야 한다는 뜻
}
```

- 런타임에 “**어떤 메서드에 어떤 어노테이션이 붙어 있는지**”를 찾고, 그에 따라 동작을 추가할 수 있다.
    

### 5-3. 스프링에서의 활용 (AOP, 트랜잭션)

- 스프링은 컨테이너 초기화 시점에:
    
    - 클래스들을 스캔하며 리플렉션으로 `@Transactional`, `@Controller`, `@Repository` 등을 찾는다.
        
    - 해당 빈에 대해 **프록시 객체**를 만들어
        
        - 메서드 호출 전/후에 트랜잭션 시작·커밋·롤백, 로깅, 보안 검사 같은 공통 관심사를 자동으로 끼워 넣는다.
            
- 구조적으로 보면:
    
    - **어노테이션 = 표지판(“이 메서드는 트랜잭션 필요”)**
        
    - **리플렉션 = 표지판을 읽는 눈**
        
    - **프록시/AOP = 읽은 정보를 바탕으로 실제 동작을 붙이는 손발**
        

---

## 6. 어노테이션 프로세싱(Annotation Processing) – 컴파일 타임 기능

### 6-1. 개념

- **정의**
    
    - 컴파일 시점에 어노테이션 정보를 분석해서 **코드를 생성하거나(소스/클래스), 규칙 위반을 검증하는 기능**.
        
- **흐름(간단)**
    
    1. `javac`가 `.java`를 파싱해서 AST(구문 트리)를 만든다.
        
    2. AST에서 어노테이션이 붙은 요소들을 모은다.
        
    3. 등록된 어노테이션 프로세서의 `process(...)`가 호출된다.
        
    4. 프로세서는
        
        - 어노테이션 사용을 검증하거나,
            
        - `Filer`를 통해 **새 `.java` 소스/리소스**를 생성한다.
            
    5. 생성된 새 소스도 포함해 다음 라운드 컴파일을 진행할 수 있다.
        

### 6-2. 구성 요소

1. **커스텀 어노테이션 정의**
    
    - `@interface`로 어노테이션 타입를 만들고
        
    - 보통 `@Retention(SOURCE)` + `@Target(...)` 지정.
        
2. **어노테이션 프로세서 구현**
    

```java
@SupportedAnnotationTypes("com.example.MyAnno")
@SupportedSourceVersion(SourceVersion.RELEASE_17)
public class MyProcessor extends AbstractProcessor {

    @Override
    public boolean process(Set<? extends TypeElement> annotations,
                           RoundEnvironment roundEnv) {
        // @MyAnno가 붙은 요소들 찾기
        Set<? extends Element> elements =
                roundEnv.getElementsAnnotatedWith(MyAnno.class);

        // 요소들을 순회하며 코드 생성/검증 수행
        // processingEnv.getFiler()로 새 소스/리소스를 만든다.
        return true;
    }
}
```

3. **Filer를 이용한 코드 생성**
    
    - `processingEnv.getFiler().createSourceFile(...)`  
        → 새 `.java` 파일 생성
        
    - `Writer`로 내용을 써 넣으면, 같은 컴파일 과정에서 함께 컴파일된다.
        
4. **프로세서 등록**
    
    - `META-INF/services/javax.annotation.processing.Processor` 파일에  
        프로세서 구현 클래스 이름(FQCN)을 적어 두면  
        → `javac`가 컴파일 시 자동으로 로드하고 실행한다.
        

### 6-3. 사용 목적

- 반복적인 보일러플레이트 코드 자동 생성 (Lombok, MapStruct, Dagger 등)
    
- 유효성 검증 (예: 잘못 붙인 어노테이션을 컴파일 에러로 막기)
    
- 메타 모델, 설정 파일, 리소스 자동 생성 (JPA 메타모델 등)
    

---

## 7. 일반 어노테이션 프로세서 vs Lombok (AST 조작)

### 7-1. 일반 어노테이션 프로세서

- **특징**
    
    - 기존 소스 파일(`User.java`) 내용은 **수정하지 못한다**.
        
    - 대신 **새 소스 파일**을 생성할 수 있다.
        
- **예시**
    
    - `User.java`는 그대로 두고,
        
    - `User_` 같은 메타모델 클래스를 **추가로** 생성하는 패턴.
        
- **포인트**
    
    - 원본 클래스의 AST는 건드리지 않고, **옆에 “보조 코드”를 만들어 붙이는 방식**.
        

### 7-2. Lombok의 방식 (AST 직접 조작)

- **Lombok이 하고 싶은 일**
    
    - `@Getter` 하나로, 원본 클래스 안에 **getter 메서드가 원래부터 있었던 것처럼** 만들고 싶다.
        
- **방법**
    
    - 표준 프로세서 API뿐 아니라, `javac` 내부 API를 사용해  
        **컴파일러의 AST를 직접 조작**한다.
        
    - `User.java`를 파싱한 AST 안에 `getId()`, `getName()` 같은 메서드 노드를 추가한다.
        
- **IDE 통합**
    
    - Lombok 플러그인이 IntelliJ/Eclipse 등의 **IDE 내부 AST도 조작**해서  
        **빌드/컴파일을 돌리지 않아도** `@Getter`가 만들어줄 메서드가 “이미 존재하는 것처럼” 보이게 한다.  
        → 빨간 줄 안 뜨고, 자동완성에도 뜸.
        
- **정리**
    
    - 일반 프로세서: **“새 파일만 생성 가능, 원본은 그대로”**
        
    - Lombok: **“AST를 직접 수정해서 원본 클래스 자체에 메서드/필드를 추가한 것처럼 만든다 + IDE도 속인다”**
        

---

## 8. 개념 한 줄 정리 모음 (멘토/면접 답변용)
- **어노테이션이 어떻게 동작하나요?**  
    → “어노테이션은 컴파일 단계에서는 컴파일러와 어노테이션 프로세서가 활용하고, 런타임 단계에서는 리플렉션을 통해 프레임워크가 동작을 붙이는 데 활용됩니다.”
- **`@Transactional`이 어노테이션 프로세서 없이도 동작하는 이유는?**  
    → “`@Transactional`은 컴파일 시에 코드를 생성하는 방식이 아니라, 런타임에 리플렉션으로 어노테이션을 읽고 프록시를 통해 트랜잭션을 시작·커밋·롤백하기 때문에 어노테이션 프로세서가 필요하지 않습니다.”
- **어노테이션 프로세싱으로 커스텀 어노테이션을 구현하는 과정은?**  
    → “먼저 `@interface`로 어노테이션을 정의하고, `AbstractProcessor`를 상속한 프로세서 클래스에서 `@SupportedAnnotationTypes`를 통해 대상 어노테이션을 지정합니다. 그리고 `process()` 메서드에서 어노테이션이 붙은 요소들을 찾은 뒤 `Filer`로 추가 소스/리소스를 생성하고, META-INF/services에 프로세서를 등록해 컴파일 시 자동으로 실행되도록 합니다.”
    
---

## 참고
- [Java Annotation Processing 을 공부하며 알아보는 Lombok(롬복)의 동작 원리](https://tech.osci.kr/java-annotation-processing/)