### AOP를 사용하는 이유
- **관심사의 분리(SoC):** 비즈니스 로직(핵심)과 로깅/트랜잭션(부가 기능)을 분리하여 코드 가독성을 높임.
- **중복 제거:** 수많은 메서드에 일일이 로그 코드를 넣지 않고, 어노테이션 하나로 제어 가능.

### Spring AOP의 동작 원리 - 프록시(Proxy)
- 스프링은 빈(Bean)을 생성할 때 원본 객체를 감싸는 **'가짜 객체(프록시)'**를 앞에 세움.
- 외부에서 호출하면 **프록시가 먼저 호출을 가로채서** 로그를 남기고, 그 다음 실제 객체의 메서드를 실행함.

### 자가 호출(Self-invocation) 이슈
- **현상:** 같은 클래스 내에서 `A()` 메서드가 `B()`를 호출할 때, `B()`에 붙은 어노테이션이 작동하지 않음.
- **원인:** `this.B()` 호출은 프록시를 거치지 않고 **원본 객체의 메모리 주소로 직접 접근**하기 때문.
- **결론:** AOP는 반드시 **'외부에서 프록시를 통해'** 호출될 때만 보장됨.

### 커스텀 어노테이션 설정
- **@Target(ElementType.METHOD):** 메서드에 붙일 것인가? (필드, 클래스 등 선택 가능)
- **@Retention(RetentionPolicy.RUNTIME):** 실행 중에도 어노테이션 정보를 참조할 수 있게 설정 (AOP 필수).

### 해결 방법 요약
1. **구조 분리:** 로직을 별도의 서비스 클래스로 쪼개서 외부 호출 형태로 만듦 (권장).
2. **자기 참조:** `@Autowired`로 자기 자신의 프록시를 주입받아 호출.